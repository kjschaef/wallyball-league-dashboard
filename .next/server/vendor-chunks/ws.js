"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ws";
exports.ids = ["vendor-chunks/ws"];
exports.modules = {

/***/ "(rsc)/./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  EMPTY_BUFFER\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst FastBuffer = Buffer[Symbol.species];\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n  if (offset < totalLength) {\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\n  }\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n  if (Buffer.isBuffer(data)) return data;\n  let buf;\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n  return buf;\n}\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = __webpack_require__(/*! bufferutil */ \"(rsc)/./node_modules/bufferutil/index.js\");\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);else bufferUtil.mask(source, mask, output, offset, length);\n    };\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLE1BQU07RUFBRUE7QUFBYSxDQUFDLEdBQUdDLG1CQUFPLENBQUMsNkRBQWEsQ0FBQztBQUUvQyxNQUFNQyxVQUFVLEdBQUdDLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDQyxPQUFPLENBQUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxNQUFNQSxDQUFDQyxJQUFJLEVBQUVDLFdBQVcsRUFBRTtFQUNqQyxJQUFJRCxJQUFJLENBQUNFLE1BQU0sS0FBSyxDQUFDLEVBQUUsT0FBT1QsWUFBWTtFQUMxQyxJQUFJTyxJQUFJLENBQUNFLE1BQU0sS0FBSyxDQUFDLEVBQUUsT0FBT0YsSUFBSSxDQUFDLENBQUMsQ0FBQztFQUVyQyxNQUFNRyxNQUFNLEdBQUdQLE1BQU0sQ0FBQ1EsV0FBVyxDQUFDSCxXQUFXLENBQUM7RUFDOUMsSUFBSUksTUFBTSxHQUFHLENBQUM7RUFFZCxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR04sSUFBSSxDQUFDRSxNQUFNLEVBQUVJLENBQUMsRUFBRSxFQUFFO0lBQ3BDLE1BQU1DLEdBQUcsR0FBR1AsSUFBSSxDQUFDTSxDQUFDLENBQUM7SUFDbkJILE1BQU0sQ0FBQ0ssR0FBRyxDQUFDRCxHQUFHLEVBQUVGLE1BQU0sQ0FBQztJQUN2QkEsTUFBTSxJQUFJRSxHQUFHLENBQUNMLE1BQU07RUFDdEI7RUFFQSxJQUFJRyxNQUFNLEdBQUdKLFdBQVcsRUFBRTtJQUN4QixPQUFPLElBQUlOLFVBQVUsQ0FBQ1EsTUFBTSxDQUFDTSxNQUFNLEVBQUVOLE1BQU0sQ0FBQ08sVUFBVSxFQUFFTCxNQUFNLENBQUM7RUFDakU7RUFFQSxPQUFPRixNQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxT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RUFBRVQsTUFBTSxFQUFFSCxNQUFNLENBQUM7SUFDNUQsQ0FBQztJQUVEd0IscUJBQXFCLEdBQUcsVUFBVWpCLE1BQU0sRUFBRUksSUFBSSxFQUFFO01BQzlDLElBQUlKLE1BQU0sQ0FBQ1AsTUFBTSxHQUFHLEVBQUUsRUFBRWEsT0FBTyxDQUFDTixNQUFNLEVBQUVJLElBQUksQ0FBQyxDQUFDLEtBQ3pDbUIsVUFBVSxDQUFDSixNQUFNLENBQUNuQixNQUFNLEVBQUVJLElBQUksQ0FBQztJQUN0QyxDQUFDO0VBQ0gsQ0FBQyxDQUFDLE9BQU9vQixDQUFDLEVBQUU7SUFDVjtFQUFBO0FBRUoiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgYnVmZmVycyBpbnRvIGEgbmV3IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBhcnJheSBvZiBidWZmZXJzIHRvIGNvbmNhdFxuICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsTGVuZ3RoIFRoZSB0b3RhbCBsZW5ndGggb2YgYnVmZmVycyBpbiB0aGUgbGlzdFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgcmVzdWx0aW5nIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjb25jYXQobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHJldHVybiBsaXN0WzBdO1xuXG4gIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJ1ZiA9IGxpc3RbaV07XG4gICAgdGFyZ2V0LnNldChidWYsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGJ1Zi5sZW5ndGg7XG4gIH1cblxuICBpZiAob2Zmc2V0IDwgdG90YWxMZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIodGFyZ2V0LmJ1ZmZlciwgdGFyZ2V0LmJ5dGVPZmZzZXQsIG9mZnNldCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIE1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBzb3VyY2UgVGhlIGJ1ZmZlciB0byBtYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBvdXRwdXQgVGhlIGJ1ZmZlciB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgd3JpdGluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIG1hc2suXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0W29mZnNldCArIGldID0gc291cmNlW2ldIF4gbWFza1tpICYgM107XG4gIH1cbn1cblxuLyoqXG4gKiBVbm1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byB1bm1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfdW5tYXNrKGJ1ZmZlciwgbWFzaykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZlcltpXSBePSBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYnVmZmVyIHRvIGFuIGBBcnJheUJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBDb252ZXJ0ZWQgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmLmJ1ZmZlcjtcbiAgfVxuXG4gIHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5sZW5ndGgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBkYXRhYCB0byBhIGBCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBidWZmZXJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9CdWZmZXIoZGF0YSkge1xuICB0b0J1ZmZlci5yZWFkT25seSA9IHRydWU7XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgcmV0dXJuIGRhdGE7XG5cbiAgbGV0IGJ1ZjtcblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgYnVmID0gbmV3IEZhc3RCdWZmZXIoZGF0YSk7XG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgYnVmID0gbmV3IEZhc3RCdWZmZXIoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICB0b0J1ZmZlci5yZWFkT25seSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbmNhdCxcbiAgbWFzazogX21hc2ssXG4gIHRvQXJyYXlCdWZmZXIsXG4gIHRvQnVmZmVyLFxuICB1bm1hc2s6IF91bm1hc2tcbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuaWYgKCFwcm9jZXNzLmVudi5XU19OT19CVUZGRVJfVVRJTCkge1xuICB0cnkge1xuICAgIGNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5tYXNrID0gZnVuY3Rpb24gKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA8IDQ4KSBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgZWxzZSBidWZmZXJVdGlsLm1hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMudW5tYXNrID0gZnVuY3Rpb24gKGJ1ZmZlciwgbWFzaykge1xuICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPCAzMikgX3VubWFzayhidWZmZXIsIG1hc2spO1xuICAgICAgZWxzZSBidWZmZXJVdGlsLnVubWFzayhidWZmZXIsIG1hc2spO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBDb250aW51ZSByZWdhcmRsZXNzIG9mIHRoZSBlcnJvci5cbiAgfVxufVxuIl0sIm5hbWVzIjpbIkVNUFRZX0JVRkZFUiIsInJlcXVpcmUiLCJGYXN0QnVmZmVyIiwiQnVmZmVyIiwiU3ltYm9sIiwic3BlY2llcyIsImNvbmNhdCIsImxpc3QiLCJ0b3RhbExlbmd0aCIsImxlbmd0aCIsInRhcmdldCIsImFsbG9jVW5zYWZlIiwib2Zmc2V0IiwiaSIsImJ1ZiIsInNldCIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJfbWFzayIsInNvdXJjZSIsIm1hc2siLCJvdXRwdXQiLCJfdW5tYXNrIiwidG9BcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJzbGljZSIsInRvQnVmZmVyIiwiZGF0YSIsInJlYWRPbmx5IiwiaXNCdWZmZXIiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImZyb20iLCJtb2R1bGUiLCJleHBvcnRzIiwidW5tYXNrIiwicHJvY2VzcyIsImVudiIsIldTX05PX0JVRkZFUl9VVElMIiwiYnVmZmVyVXRpbCIsImUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {

eval("\n\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\nconst hasBlob = typeof Blob !== 'undefined';\nif (hasBlob) BINARY_TYPES.push('blob');\nmodule.exports = {\n  BINARY_TYPES,\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  hasBlob,\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixNQUFNQSxZQUFZLEdBQUcsQ0FBQyxZQUFZLEVBQUUsYUFBYSxFQUFFLFdBQVcsQ0FBQztBQUMvRCxNQUFNQyxPQUFPLEdBQUcsT0FBT0MsSUFBSSxLQUFLLFdBQVc7QUFFM0MsSUFBSUQsT0FBTyxFQUFFRCxZQUFZLENBQUNHLElBQUksQ0FBQyxNQUFNLENBQUM7QUFFdENDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHO0VBQ2ZMLFlBQVk7RUFDWk0sWUFBWSxFQUFFQyxNQUFNLENBQUNDLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDN0JDLElBQUksRUFBRSxzQ0FBc0M7RUFDNUNSLE9BQU87RUFDUFMsb0JBQW9CLEVBQUVDLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQztFQUN0REMsU0FBUyxFQUFFRCxNQUFNLENBQUMsV0FBVyxDQUFDO0VBQzlCRSxXQUFXLEVBQUVGLE1BQU0sQ0FBQyxhQUFhLENBQUM7RUFDbENHLFVBQVUsRUFBRUgsTUFBTSxDQUFDLFdBQVcsQ0FBQztFQUMvQkksSUFBSSxFQUFFQSxDQUFBLEtBQU0sQ0FBQztBQUNmLENBQUMiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3dzL2xpYi9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCSU5BUllfVFlQRVMgPSBbJ25vZGVidWZmZXInLCAnYXJyYXlidWZmZXInLCAnZnJhZ21lbnRzJ107XG5jb25zdCBoYXNCbG9iID0gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnO1xuXG5pZiAoaGFzQmxvYikgQklOQVJZX1RZUEVTLnB1c2goJ2Jsb2InKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSOiBCdWZmZXIuYWxsb2MoMCksXG4gIEdVSUQ6ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnLFxuICBoYXNCbG9iLFxuICBrRm9yT25FdmVudEF0dHJpYnV0ZTogU3ltYm9sKCdrSXNGb3JPbkV2ZW50QXR0cmlidXRlJyksXG4gIGtMaXN0ZW5lcjogU3ltYm9sKCdrTGlzdGVuZXInKSxcbiAga1N0YXR1c0NvZGU6IFN5bWJvbCgnc3RhdHVzLWNvZGUnKSxcbiAga1dlYlNvY2tldDogU3ltYm9sKCd3ZWJzb2NrZXQnKSxcbiAgTk9PUDogKCkgPT4ge31cbn07XG4iXSwibmFtZXMiOlsiQklOQVJZX1RZUEVTIiwiaGFzQmxvYiIsIkJsb2IiLCJwdXNoIiwibW9kdWxlIiwiZXhwb3J0cyIsIkVNUFRZX0JVRkZFUiIsIkJ1ZmZlciIsImFsbG9jIiwiR1VJRCIsImtGb3JPbkV2ZW50QXR0cmlidXRlIiwiU3ltYm9sIiwia0xpc3RlbmVyIiwia1N0YXR1c0NvZGUiLCJrV2ViU29ja2V0IiwiTk9PUCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  kForOnEventAttribute,\n  kListener\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\nObject.defineProperty(Event.prototype, 'target', {\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, 'type', {\n  enumerable: true\n});\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\nObject.defineProperty(CloseEvent.prototype, 'code', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'reason', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'wasClean', {\n  enumerable: true\n});\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\nObject.defineProperty(ErrorEvent.prototype, 'error', {\n  enumerable: true\n});\nObject.defineProperty(ErrorEvent.prototype, 'message', {\n  enumerable: true\n});\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\nObject.defineProperty(MessageEvent.prototype, 'data', {\n  enumerable: true\n});\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        return;\n      }\n    }\n    let wrapper;\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixNQUFNO0VBQUVBLG9CQUFvQjtFQUFFQztBQUFVLENBQUMsR0FBR0MsbUJBQU8sQ0FBQyw2REFBYSxDQUFDO0FBRWxFLE1BQU1DLEtBQUssR0FBR0MsTUFBTSxDQUFDLE9BQU8sQ0FBQztBQUM3QixNQUFNQyxLQUFLLEdBQUdELE1BQU0sQ0FBQyxPQUFPLENBQUM7QUFDN0IsTUFBTUUsTUFBTSxHQUFHRixNQUFNLENBQUMsUUFBUSxDQUFDO0FBQy9CLE1BQU1HLFFBQVEsR0FBR0gsTUFBTSxDQUFDLFVBQVUsQ0FBQztBQUNuQyxNQUFNSSxPQUFPLEdBQUdKLE1BQU0sQ0FBQyxTQUFTLENBQUM7QUFDakMsTUFBTUssT0FBTyxHQUFHTCxNQUFNLENBQUMsU0FBUyxDQUFDO0FBQ2pDLE1BQU1NLEtBQUssR0FBR04sTUFBTSxDQUFDLE9BQU8sQ0FBQztBQUM3QixNQUFNTyxTQUFTLEdBQUdQLE1BQU0sQ0FBQyxXQUFXLENBQUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLE1BQU1RLEtBQUssQ0FBQztFQUNWO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFQyxXQUFXQSxDQUFDQyxJQUFJLEVBQUU7SUFDaEIsSUFBSSxDQUFDTCxPQUFPLENBQUMsR0FBRyxJQUFJO0lBQ3BCLElBQUksQ0FBQ0MsS0FBSyxDQUFDLEdBQUdJLElBQUk7RUFDcEI7O0VBRUE7QUFDRjtBQUNBO0VBQ0UsSUFBSUMsTUFBTUEsQ0FBQSxFQUFHO0lBQ1gsT0FBTyxJQUFJLENBQUNOLE9BQU8sQ0FBQztFQUN0Qjs7RUFFQTtBQUNGO0FBQ0E7RUFDRSxJQUFJSyxJQUFJQSxDQUFBLEVBQUc7SUFDVCxPQUFPLElBQUksQ0FBQ0osS0FBSyxDQUFDO0VBQ3BCO0FBQ0Y7QUFFQU0sTUFBTSxDQUFDQyxjQUFjLENBQUNMLEtBQUssQ0FBQ00sU0FBUyxFQUFFLFFBQVEsRUFBRTtFQUFF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QVEsQ0FBQztRQUNuQztNQUNGO0lBQ0Y7RUFDRjtBQUNGLENBQUM7QUFFRGlCLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHO0VBQ2ZoQyxVQUFVO0VBQ1ZNLFVBQVU7RUFDVmQsS0FBSztFQUNMbUIsV0FBVztFQUNYRjtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNZLFlBQVlBLENBQUNQLFFBQVEsRUFBRW1CLE9BQU8sRUFBRWQsS0FBSyxFQUFFO0VBQzlDLElBQUksT0FBT0wsUUFBUSxLQUFLLFFBQVEsSUFBSUEsUUFBUSxDQUFDb0IsV0FBVyxFQUFFO0lBQ3hEcEIsUUFBUSxDQUFDb0IsV0FBVyxDQUFDQyxJQUFJLENBQUNyQixRQUFRLEVBQUVLLEtBQUssQ0FBQztFQUM1QyxDQUFDLE1BQU07SUFDTEwsUUFBUSxDQUFDcUIsSUFBSSxDQUFDRixPQUFPLEVBQUVkLEtBQUssQ0FBQztFQUMvQjtBQUNGIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy93cy9saWIvZXZlbnQtdGFyZ2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBrRm9yT25FdmVudEF0dHJpYnV0ZSwga0xpc3RlbmVyIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBrQ29kZSA9IFN5bWJvbCgna0NvZGUnKTtcbmNvbnN0IGtEYXRhID0gU3ltYm9sKCdrRGF0YScpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdrRXJyb3InKTtcbmNvbnN0IGtNZXNzYWdlID0gU3ltYm9sKCdrTWVzc2FnZScpO1xuY29uc3Qga1JlYXNvbiA9IFN5bWJvbCgna1JlYXNvbicpO1xuY29uc3Qga1RhcmdldCA9IFN5bWJvbCgna1RhcmdldCcpO1xuY29uc3Qga1R5cGUgPSBTeW1ib2woJ2tUeXBlJyk7XG5jb25zdCBrV2FzQ2xlYW4gPSBTeW1ib2woJ2tXYXNDbGVhbicpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBldmVudC5cbiAqL1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBgdHlwZWAgYXJndW1lbnQgaXMgbm90IHNwZWNpZmllZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHRoaXNba1RhcmdldF0gPSBudWxsO1xuICAgIHRoaXNba1R5cGVdID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCB0YXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXNba1RhcmdldF07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzW2tUeXBlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndGFyZ2V0JywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3R5cGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2xvc2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQ2xvc2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvZGU9MF0gVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZVxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZWFzb249JyddIEEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGV4cGxhaW5pbmcgd2h5XG4gICAqICAgICB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2FzQ2xlYW49ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsZWFubHkgY2xvc2VkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0NvZGVdID0gb3B0aW9ucy5jb2RlID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5jb2RlO1xuICAgIHRoaXNba1JlYXNvbl0gPSBvcHRpb25zLnJlYXNvbiA9PT0gdW5kZWZpbmVkID8gJycgOiBvcHRpb25zLnJlYXNvbjtcbiAgICB0aGlzW2tXYXNDbGVhbl0gPSBvcHRpb25zLndhc0NsZWFuID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMud2FzQ2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzW2tDb2RlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpc1trUmVhc29uXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCB3YXNDbGVhbigpIHtcbiAgICByZXR1cm4gdGhpc1trV2FzQ2xlYW5dO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ2NvZGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdyZWFzb24nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICd3YXNDbGVhbicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXJyb3IgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXJyb3JFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5lcnJvcj1udWxsXSBUaGUgZXJyb3IgdGhhdCBnZW5lcmF0ZWQgdGhpcyBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZT0nJ10gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRXJyb3JdID0gb3B0aW9ucy5lcnJvciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZXJyb3I7XG4gICAgdGhpc1trTWVzc2FnZV0gPSBvcHRpb25zLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5tZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzW2tFcnJvcl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBtZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzW2tNZXNzYWdlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdlcnJvcicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgJ21lc3NhZ2UnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWVzc2FnZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYE1lc3NhZ2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5kYXRhPW51bGxdIFRoZSBtZXNzYWdlIGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRGF0YV0gPSBvcHRpb25zLmRhdGEgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpc1trRGF0YV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VFdmVudC5wcm90b3R5cGUsICdkYXRhJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIFRoaXMgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZW11bGF0aW5nIHRoZSBgRXZlbnRUYXJnZXRgIGludGVyZmFjZS4gSXQncyBub3RcbiAqIG1lYW50IHRvIGJlIHVzZWQgZGlyZWN0bHkuXG4gKlxuICogQG1peGluXG4gKi9cbmNvbnN0IEV2ZW50VGFyZ2V0ID0ge1xuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yXG4gICAqIEBwYXJhbSB7KEZ1bmN0aW9ufE9iamVjdCl9IGhhbmRsZXIgVGhlIGxpc3RlbmVyIHRvIGFkZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcbiAgICogICAgIHRoZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9uY2U9ZmFsc2VdIEEgYEJvb2xlYW5gIGluZGljYXRpbmcgdGhhdCB0aGVcbiAgICogICAgIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZyBhZGRlZC4gSWYgYHRydWVgLFxuICAgKiAgICAgdGhlIGxpc3RlbmVyIHdvdWxkIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCB3aGVuIGludm9rZWQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xuICAgICAgaWYgKFxuICAgICAgICAhb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZV0gJiZcbiAgICAgICAgbGlzdGVuZXJba0xpc3RlbmVyXSA9PT0gaGFuZGxlciAmJlxuICAgICAgICAhbGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB3cmFwcGVyO1xuXG4gICAgaWYgKHR5cGUgPT09ICdtZXNzYWdlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgZGF0YTogaXNCaW5hcnkgPyBkYXRhIDogZGF0YS50b1N0cmluZygpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2xvc2UnKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25DbG9zZShjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IENsb3NlRXZlbnQoJ2Nsb3NlJywge1xuICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgcmVhc29uOiBtZXNzYWdlLnRvU3RyaW5nKCksXG4gICAgICAgICAgd2FzQ2xlYW46IHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJiB0aGlzLl9jbG9zZUZyYW1lU2VudFxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7XG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29wZW4nKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25PcGVuKCkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnb3BlbicpO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3cmFwcGVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSA9ICEhb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZV07XG4gICAgd3JhcHBlcltrTGlzdGVuZXJdID0gaGFuZGxlcjtcblxuICAgIGlmIChvcHRpb25zLm9uY2UpIHtcbiAgICAgIHRoaXMub25jZSh0eXBlLCB3cmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbih0eXBlLCB3cmFwcGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xuICAgICAgaWYgKGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiYgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2xvc2VFdmVudCxcbiAgRXJyb3JFdmVudCxcbiAgRXZlbnQsXG4gIEV2ZW50VGFyZ2V0LFxuICBNZXNzYWdlRXZlbnRcbn07XG5cbi8qKlxuICogQ2FsbCBhbiBldmVudCBsaXN0ZW5lclxuICpcbiAqIEBwYXJhbSB7KEZ1bmN0aW9ufE9iamVjdCl9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjYWxsXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIHZhbHVlIHRvIHVzZSBhcyBgdGhpc2BgIHdoZW4gY2FsbGluZyB0aGUgbGlzdGVuZXJcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBwYXNzIHRvIHRoZSBsaXN0ZW5lclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsbExpc3RlbmVyKGxpc3RlbmVyLCB0aGlzQXJnLCBldmVudCkge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JyAmJiBsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xuICAgIGxpc3RlbmVyLmhhbmRsZUV2ZW50LmNhbGwobGlzdGVuZXIsIGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0ZW5lci5jYWxsKHRoaXNBcmcsIGV2ZW50KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImtGb3JPbkV2ZW50QXR0cmlidXRlIiwia0xpc3RlbmVyIiwicmVxdWlyZSIsImtDb2RlIiwiU3ltYm9sIiwia0RhdGEiLCJrRXJyb3IiLCJrTWVzc2FnZSIsImtSZWFzb24iLCJrVGFyZ2V0Iiwia1R5cGUiLCJrV2FzQ2xlYW4iLCJFdmVudCIsImNvbnN0cnVjdG9yIiwidHlwZSIsInRhcmdldCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiZW51bWVyYWJsZSIsIkNsb3NlRXZlbnQiLCJvcHRpb25zIiwiY29kZSIsInVuZGVmaW5lZCIsInJlYXNvbiIsIndhc0NsZWFuIiwiRXJyb3JFdmVudCIsImVycm9yIiwibWVzc2FnZSIsIk1lc3NhZ2VFdmVudCIsImRhdGEiLCJFdmVudFRhcmdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJoYW5kbGVyIiwibGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJ3cmFwcGVyIiwib25NZXNzYWdlIiwiaXNCaW5hcnkiLCJldmVudCIsInRvU3RyaW5nIiwiY2FsbExpc3RlbmVyIiwib25DbG9zZSIsIl9jbG9zZUZyYW1lUmVjZWl2ZWQiLCJfY2xvc2VGcmFtZVNlbnQiLCJvbkVycm9yIiwib25PcGVuIiwib25jZSIsIm9uIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwibW9kdWxlIiwiZXhwb3J0cyIsInRoaXNBcmciLCJoYW5kbGVFdmVudCIsImNhbGwiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  tokenChars\n} = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (i !== 0 && (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions).map(extension => {\n    let configurations = extensions[extension];\n    if (!Array.isArray(configurations)) configurations = [configurations];\n    return configurations.map(params => {\n      return [extension].concat(Object.keys(params).map(k => {\n        let values = params[k];\n        if (!Array.isArray(values)) values = [values];\n        return values.map(v => v === true ? k : `${k}=${v}`).join('; ');\n      })).join('; ');\n    }).join(', ');\n  }).join(', ');\n}\nmodule.exports = {\n  format,\n  parse\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixNQUFNO0VBQUVBO0FBQVcsQ0FBQyxHQUFHQyxtQkFBTyxDQUFDLCtEQUFjLENBQUM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0MsSUFBSUEsQ0FBQ0MsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRTtFQUM5QixJQUFJRixJQUFJLENBQUNDLElBQUksQ0FBQyxLQUFLRSxTQUFTLEVBQUVILElBQUksQ0FBQ0MsSUFBSSxDQUFDLEdBQUcsQ0FBQ0MsSUFBSSxDQUFDLENBQUMsS0FDN0NGLElBQUksQ0FBQ0MsSUFBSSxDQUFDLENBQUNGLElBQUksQ0FBQ0csSUFBSSxDQUFDO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0UsS0FBS0EsQ0FBQ0MsTUFBTSxFQUFFO0VBQ3JCLE1BQU1DLE1BQU0sR0FBR0MsTUFBTSxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDO0VBQ2xDLElBQUlDLE1BQU0sR0FBR0YsTUFBTSxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDO0VBQ2hDLElBQUlFLFlBQVksR0FBRyxLQUFLO0VBQ3hCLElBQUlDLFVBQVUsR0FBRyxLQUFLO0VBQ3RCLElBQUlDLFFBQVEsR0FBRyxLQUFLO0VBQ3BCLElBQUlDLGFBQWE7RUFDakIsSUFBSUMsU0FBUztFQUNiLElBQUlDLEtBQUssR0FBRyxDQUFDLENBQUM7RUFDZCxJQUFJQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0VBQ2IsSUFBSUMsR0FBRyxHQUFHLENBQUMsQ0FBQztFQUNaLElBQUlDLENBQUMsR0FBRyxDQUFDO0VBRVQsT0FBT0EsQ0FBQyxHQUFHYixNQUFNLENBQUNjLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUU7SUFDN0JGLElBQUksR0FBR1gsTUFBTSxDQUFDZSxV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RUFBRXRCO0FBQU0sQ0FBQyIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGkgIT09IDAgJiZcbiAgICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgICApIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QgLyogJz0nICovICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXG4gICAgICAvLyB0b2tlbiBBQk5GLCBzbyBvbmx5IHRva2VuIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgICAgLy9cbiAgICAgIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xuICAgICAgICBpc0VzY2FwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4M2QpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcyB8fCBjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iXSwibmFtZXMiOlsidG9rZW5DaGFycyIsInJlcXVpcmUiLCJwdXNoIiwiZGVzdCIsIm5hbWUiLCJlbGVtIiwidW5kZWZpbmVkIiwicGFyc2UiLCJoZWFkZXIiLCJvZmZlcnMiLCJPYmplY3QiLCJjcmVhdGUiLCJwYXJhbXMiLCJtdXN0VW5lc2NhcGUiLCJpc0VzY2FwaW5nIiwiaW5RdW90ZXMiLCJleHRlbnNpb25OYW1lIiwicGFyYW1OYW1lIiwic3RhcnQiLCJjb2RlIiwiZW5kIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJTeW50YXhFcnJvciIsInNsaWNlIiwidmFsdWUiLCJyZXBsYWNlIiwidG9rZW4iLCJmb3JtYXQiLCJleHRlbnNpb25zIiwia2V5cyIsIm1hcCIsImV4dGVuc2lvbiIsImNvbmZpZ3VyYXRpb25zIiwiQXJyYXkiLCJpc0FycmF5IiwiY29uY2F0IiwiayIsInZhbHVlcyIsInYiLCJqb2luIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {

eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\nmodule.exports = Limiter;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsTUFBTUEsS0FBSyxHQUFHQyxNQUFNLENBQUMsT0FBTyxDQUFDO0FBQzdCLE1BQU1DLElBQUksR0FBR0QsTUFBTSxDQUFDLE1BQU0sQ0FBQzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNRSxPQUFPLENBQUM7RUFDWjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUMsV0FBV0EsQ0FBQ0MsV0FBVyxFQUFFO0lBQ3ZCLElBQUksQ0FBQ0wsS0FBSyxDQUFDLEdBQUcsTUFBTTtNQUNsQixJQUFJLENBQUNNLE9BQU8sRUFBRTtNQUNkLElBQUksQ0FBQ0osSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNkLENBQUM7SUFDRCxJQUFJLENBQUNHLFdBQVcsR0FBR0EsV0FBVyxJQUFJRSxRQUFRO0lBQzFDLElBQUksQ0FBQ0MsSUFBSSxHQUFHLEVBQUU7SUFDZCxJQUFJLENBQUNGLE9BQU8sR0FBRyxDQUFDO0VBQ2xCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFRyxHQUFHQSxDQUFDQyxHQUFHLEVBQUU7SUFDUCxJQUFJLENBQUNGLElBQUksQ0FBQ0csSUFBSSxDQUFDRCxHQUFHLENBQUM7SUFDbkIsSUFBSSxDQUFDUixJQUFJLENBQUMsQ0FBQyxDQUFDO0VBQ2Q7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLENBQUNBLElBQUksSUFBSTtJQUNQLElBQUksSUFBSSxDQUFDSSxPQUFPLEtBQUssSUFBSSxDQUFDRCxXQUFXLEVBQUU7SUFFdkMsSUFBSSxJQUFJLENBQUNHLElBQUksQ0FBQ0ksTUFBTSxFQUFFO01BQ3BCLE1BQU1GLEdBQUcsR0FBRyxJQUFJLENBQUNGLElBQUksQ0FBQ0ssS0FBSyxDQUFDLENBQUM7TUFFN0IsSUFBSSxDQUFDUCxPQUFPLEVBQUU7TUFDZEksR0FBRyxDQUFDLElBQUksQ0FBQ1YsS0FBSyxDQUFDLENBQUM7SUFDbEI7RUFDRjtBQUNGO0FBRUFjLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHWixPQUFPIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xuY29uc3Qga1J1biA9IFN5bWJvbCgna1J1bicpO1xuXG4vKipcbiAqIEEgdmVyeSBzaW1wbGUgam9iIHF1ZXVlIHdpdGggYWRqdXN0YWJsZSBjb25jdXJyZW5jeS4gQWRhcHRlZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU1RSTUwvYXN5bmMtbGltaXRlclxuICovXG5jbGFzcyBMaW1pdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygam9icyBhbGxvd2VkXG4gICAqICAgICB0byBydW4gY29uY3VycmVudGx5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25jdXJyZW5jeSkge1xuICAgIHRoaXNba0RvbmVdID0gKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nLS07XG4gICAgICB0aGlzW2tSdW5dKCk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3kgfHwgSW5maW5pdHk7XG4gICAgdGhpcy5qb2JzID0gW107XG4gICAgdGhpcy5wZW5kaW5nID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgam9iIHRvIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gam9iIFRoZSBqb2IgdG8gcnVuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZChqb2IpIHtcbiAgICB0aGlzLmpvYnMucHVzaChqb2IpO1xuICAgIHRoaXNba1J1bl0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW2tSdW5dKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmcgPT09IHRoaXMuY29uY3VycmVuY3kpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBqb2IgPSB0aGlzLmpvYnMuc2hpZnQoKTtcblxuICAgICAgdGhpcy5wZW5kaW5nKys7XG4gICAgICBqb2IodGhpc1trRG9uZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZXI7XG4iXSwibmFtZXMiOlsia0RvbmUiLCJTeW1ib2wiLCJrUnVuIiwiTGltaXRlciIsImNvbnN0cnVjdG9yIiwiY29uY3VycmVuY3kiLCJwZW5kaW5nIiwiSW5maW5pdHkiLCJqb2JzIiwiYWRkIiwiam9iIiwicHVzaCIsImxlbmd0aCIsInNoaWZ0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(rsc)/./node_modules/ws/lib/limiter.js\");\nconst {\n  kStatusCode\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n    this.params = null;\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n      this._deflate.close();\n      this._deflate = null;\n      if (callback) {\n        callback(new Error('The deflate stream was closed while data was being processed'));\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find(params => {\n      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {\n        return false;\n      }\n      return true;\n    });\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n      delete accepted.client_max_window_bits;\n    }\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n      throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n    }\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach(params => {\n      Object.keys(params).forEach(key => {\n        let value = params[key];\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n        value = value[0];\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n          value = num;\n        } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {\n          if (value !== true) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n        params[key] = value;\n      });\n    });\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n    this._inflate[kCallback] = callback;\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n      const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      this._deflate.on('data', deflateOnData);\n    }\n    this._deflate[kCallback] = callback;\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n      let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n      if (fin) {\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n      }\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n      callback(null, data);\n    });\n  }\n}\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixNQUFNQSxJQUFJLEdBQUdDLG1CQUFPLENBQUMsa0JBQU0sQ0FBQztBQUU1QixNQUFNQyxVQUFVLEdBQUdELG1CQUFPLENBQUMsaUVBQWUsQ0FBQztBQUMzQyxNQUFNRSxPQUFPLEdBQUdGLG1CQUFPLENBQUMseURBQVcsQ0FBQztBQUNwQyxNQUFNO0VBQUVHO0FBQVksQ0FBQyxHQUFHSCxtQkFBTyxDQUFDLDZEQUFhLENBQUM7QUFFOUMsTUFBTUksVUFBVSxHQUFHQyxNQUFNLENBQUNDLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDO0FBQ3pDLE1BQU1DLE9BQU8sR0FBR0gsTUFBTSxDQUFDSSxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNyRCxNQUFNQyxrQkFBa0IsR0FBR0osTUFBTSxDQUFDLG9CQUFvQixDQUFDO0FBQ3ZELE1BQU1LLFlBQVksR0FBR0wsTUFBTSxDQUFDLGNBQWMsQ0FBQztBQUMzQyxNQUFNTSxTQUFTLEdBQUdOLE1BQU0sQ0FBQyxVQUFVLENBQUM7QUFDcEMsTUFBTU8sUUFBUSxHQUFHUCxNQUFNLENBQUMsU0FBUyxDQUFDO0FBQ2xDLE1BQU1RLE1BQU0sR0FBR1IsTUFBTSxDQUFDLE9BQU8sQ0FBQzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJUyxXQUFXOztBQUVmO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLGlCQUFpQixDQUFDO0VBQ3RCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFQyxXQUFXQSxDQUFDQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMs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Z2UtZGVmbGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCBMaW1pdGVyID0gcmVxdWlyZSgnLi9saW1pdGVyJyk7XG5jb25zdCB7IGtTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcbmNvbnN0IFRSQUlMRVIgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHhmZiwgMHhmZl0pO1xuY29uc3Qga1Blck1lc3NhZ2VEZWZsYXRlID0gU3ltYm9sKCdwZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IGtUb3RhbExlbmd0aCA9IFN5bWJvbCgndG90YWwtbGVuZ3RoJyk7XG5jb25zdCBrQ2FsbGJhY2sgPSBTeW1ib2woJ2NhbGxiYWNrJyk7XG5jb25zdCBrQnVmZmVycyA9IFN5bWJvbCgnYnVmZmVycycpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xuXG4vL1xuLy8gV2UgbGltaXQgemxpYiBjb25jdXJyZW5jeSwgd2hpY2ggcHJldmVudHMgc2V2ZXJlIG1lbW9yeSBmcmFnbWVudGF0aW9uXG4vLyBhcyBkb2N1bWVudGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvODg3MSNpc3N1ZWNvbW1lbnQtMjUwOTE1OTEzXG4vLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzEyMDJcbi8vXG4vLyBJbnRlbnRpb25hbGx5IGdsb2JhbDsgaXQncyB0aGUgZ2xvYmFsIHRocmVhZCBwb29sIHRoYXQncyBhbiBpc3N1ZS5cbi8vXG5sZXQgemxpYkxpbWl0ZXI7XG5cbi8qKlxuICogcGVybWVzc2FnZS1kZWZsYXRlIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBQZXJNZXNzYWdlRGVmbGF0ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUGVyTWVzc2FnZURlZmxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0c10gQWR2ZXJ0aXNlIHN1cHBvcnRcbiAgICogICAgIGZvciwgb3IgcmVxdWVzdCwgYSBjdXN0b20gY2xpZW50IHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIEFkdmVydGlzZS9cbiAgICogICAgIGFja25vd2xlZGdlIGRpc2FibGluZyBvZiBjbGllbnQgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29uY3VycmVuY3lMaW1pdD0xMF0gVGhlIG51bWJlciBvZiBjb25jdXJyZW50XG4gICAqICAgICBjYWxscyB0byB6bGliXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0c10gUmVxdWVzdC9jb25maXJtIHRoZVxuICAgKiAgICAgdXNlIG9mIGEgY3VzdG9tIHNlcnZlciB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBSZXF1ZXN0L2FjY2VwdFxuICAgKiAgICAgZGlzYWJsaW5nIG9mIHNlcnZlciBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9MTAyNF0gU2l6ZSAoaW4gYnl0ZXMpIGJlbG93IHdoaWNoXG4gICAqICAgICBtZXNzYWdlcyBzaG91bGQgbm90IGJlIGNvbXByZXNzZWQgaWYgY29udGV4dCB0YWtlb3ZlciBpcyBkaXNhYmxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgZGVmbGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgaW5mbGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1NlcnZlcj1mYWxzZV0gQ3JlYXRlIHRoZSBpbnN0YW5jZSBpbiBlaXRoZXIgc2VydmVyIG9yXG4gICAqICAgICBjbGllbnQgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaXNTZXJ2ZXIsIG1heFBheWxvYWQpIHtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fdGhyZXNob2xkID1cbiAgICAgIHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCA6IDEwMjQ7XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIWlzU2VydmVyO1xuICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuXG4gICAgaWYgKCF6bGliTGltaXRlcikge1xuICAgICAgY29uc3QgY29uY3VycmVuY3kgPVxuICAgICAgICB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0XG4gICAgICAgICAgOiAxMDtcbiAgICAgIHpsaWJMaW1pdGVyID0gbmV3IExpbWl0ZXIoY29uY3VycmVuY3kpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBleHRlbnNpb25OYW1lKCkge1xuICAgIHJldHVybiAncGVybWVzc2FnZS1kZWZsYXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG9mZmVyKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT0gbnVsbCkge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci9yZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWNjZXB0KGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucyk7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHRoaXMuX2lzU2VydmVyXG4gICAgICA/IHRoaXMuYWNjZXB0QXNTZXJ2ZXIoY29uZmlndXJhdGlvbnMpXG4gICAgICA6IHRoaXMuYWNjZXB0QXNDbGllbnQoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXMucGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFsbCByZXNvdXJjZXMgdXNlZCBieSB0aGUgZXh0ZW5zaW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLl9pbmZsYXRlKSB7XG4gICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZCdcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqICBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBvZmZlcnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnNcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc1NlcnZlcihvZmZlcnMpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCBhY2NlcHRlZCA9IG9mZmVycy5maW5kKChwYXJhbXMpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyKSB8fFxuICAgICAgICAocGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgJiZcbiAgICAgICAgICAob3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA+IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzKSkpIHx8XG4gICAgICAgICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFhY2NlcHRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIHRoZSBleHRlbnNpb24gb2ZmZXJzIGNhbiBiZSBhY2NlcHRlZCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRzLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX21heF93aW5kb3dfYml0cyA9IG9wdHMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID09PSB0cnVlIHx8XG4gICAgICBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlXG4gICAgKSB7XG4gICAgICBkZWxldGUgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cztcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjZXB0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IHRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3BvbnNlIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc0NsaWVudChyZXNwb25zZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJlc3BvbnNlWzBdO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhcmFtZXRlciBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA+IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VuZXhwZWN0ZWQgb3IgaW52YWxpZCBwYXJhbWV0ZXIgXCJjbGllbnRfbWF4X3dpbmRvd19iaXRzXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBvZmZlcnMvcmVzcG9uc2Ugd2l0aCBub3JtYWxpemVkIHBhcmFtZXRlcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zLmZvckVhY2goKHBhcmFtcykgPT4ge1xuICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2tleV07XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7a2V5fVwiIG11c3QgaGF2ZSBvbmx5IGEgc2luZ2xlIHZhbHVlYCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGllbnRfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1NlcnZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NlcnZlcl9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcicgfHxcbiAgICAgICAgICBrZXkgPT09ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBcIiR7a2V5fVwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29uZmlndXJhdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9kZWNvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9jb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG5cbiAgICBpZiAoIXRoaXMuX2luZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2luZmxhdGVba1Blck1lc3NhZ2VEZWZsYXRlXSA9IHRoaXM7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2Vycm9yJywgaW5mbGF0ZU9uRXJyb3IpO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2luZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5faW5mbGF0ZS53cml0ZShkYXRhKTtcbiAgICBpZiAoZmluKSB0aGlzLl9pbmZsYXRlLndyaXRlKFRSQUlMRVIpO1xuXG4gICAgdGhpcy5faW5mbGF0ZS5mbHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl9pbmZsYXRlW2tFcnJvcl07XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLl9pbmZsYXRlLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgICAgdGhpcy5faW5mbGF0ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdzZXJ2ZXInIDogJ2NsaWVudCc7XG5cbiAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZSA9IHpsaWIuY3JlYXRlRGVmbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUub24oJ2RhdGEnLCBkZWZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2RlZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgdGhpcy5fZGVmbGF0ZS5mbHVzaCh6bGliLlpfU1lOQ19GTFVTSCwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgLy9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAoZmluKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmxlbmd0aCAtIDQpO1xuICAgICAgfVxuXG4gICAgICAvL1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCBhZ2FpbiBpblxuICAgICAgLy8gYFBlck1lc3NhZ2VEZWZsYXRlI2NsZWFudXAoKWAuXG4gICAgICAvL1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gbnVsbDtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICB0aGlzLl9kZWZsYXRlLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVyTWVzc2FnZURlZmxhdGU7XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5EZWZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG5cbiAgaWYgKFxuICAgIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZCA8IDEgfHxcbiAgICB0aGlzW2tUb3RhbExlbmd0aF0gPD0gdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkXG4gICkge1xuICAgIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXNba0Vycm9yXSA9IG5ldyBSYW5nZUVycm9yKCdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyk7XG4gIHRoaXNba0Vycm9yXS5jb2RlID0gJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCc7XG4gIHRoaXNba0Vycm9yXVtrU3RhdHVzQ29kZV0gPSAxMDA5O1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25FcnJvcihlcnIpIHtcbiAgLy9cbiAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGBabGliI2Nsb3NlKClgIGFzIHRoZSBoYW5kbGUgaXMgYXV0b21hdGljYWxseVxuICAvLyBjbG9zZWQgd2hlbiBhbiBlcnJvciBpcyBlbWl0dGVkLlxuICAvL1xuICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX2luZmxhdGUgPSBudWxsO1xuICBlcnJba1N0YXR1c0NvZGVdID0gMTAwNztcbiAgdGhpc1trQ2FsbGJhY2tdKGVycik7XG59XG4iXSwibmFtZXMiOlsiemxpYiIsInJlcXVpcmUiLCJidWZmZXJVdGlsIiwiTGltaXRlciIsImtTdGF0dXNDb2RlIiwiRmFzdEJ1ZmZlciIsIkJ1ZmZlciIsIlN5bWJvbCIsInNwZWNpZXMiLCJUUkFJTEVSIiwiZnJvbSIsImtQZXJNZXNzYWdlRGVmbGF0ZSIsImtUb3RhbExlbmd0aCIsImtDYWxsYmFjayIsImtCdWZmZXJzIiwia0Vycm9yIiwiemxpYkxpbWl0ZXIiLCJQZXJNZXNzYWdlRGVmbGF0ZSIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImlzU2VydmVyIiwibWF4UGF5bG9hZCIsIl9tYXhQYXlsb2FkIiwiX29wdGlvbnMiLCJfdGhyZXNob2xkIiwidGhyZXNob2xkIiwidW5kZWZpbmVkIiwiX2lzU2VydmVyIiwiX2RlZmxhdGUiLCJfaW5mbGF0ZSIsInBhcmFtcyIsImNvbmN1cnJlbmN5IiwiY29uY3VycmVuY3lMaW1pdCIsImV4dGVuc2lvbk5hbWUiLCJvZmZlciIsInNlcnZlck5vQ29udGV4dFRha2VvdmVyIiwic2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIiLCJjbGllbnROb0NvbnRleHRUYWtlb3ZlciIsImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyIiwic2VydmVyTWF4V2luZG93Qml0cyIsInNlcnZlcl9tYXhfd2luZG93X2JpdHMiLCJjbGllbnRNYXhXaW5kb3dCaXRzIiwiY2xpZW50X21heF93aW5kb3dfYml0cyIsImFjY2VwdCIsImNvbmZpZ3VyYXRpb25zIiwibm9ybWFsaXplUGFyYW1zIiwiYWNjZXB0QXNTZXJ2ZXIiLCJhY2NlcHRBc0NsaWVudCIsImNsZWFudXAiLCJjbG9zZSIsImNhbGxiYWNrIiwiRXJyb3IiLCJvZmZlcnMiLCJvcHRzIiwiYWNjZXB0ZWQiLCJmaW5kIiwicmVzcG9uc2UiLCJmb3JFYWNoIiwiT2JqZWN0Iiwia2V5cyIsImtleSIsInZhbHVlIiwibGVuZ3RoIiwibnVtIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiVHlwZUVycm9yIiwiZGVjb21wcmVzcyIsImRhdGEiLCJmaW4iLCJhZGQiLCJkb25lIiwiX2RlY29tcHJlc3MiLCJlcnIiLCJyZXN1bHQiLCJjb21wcmVzcyIsIl9jb21wcmVzcyIsImVuZHBvaW50Iiwid2luZG93Qml0cyIsIlpfREVGQVVMVF9XSU5ET1dCSVRTIiwiY3JlYXRlSW5mbGF0ZVJhdyIsInpsaWJJbmZsYXRlT3B0aW9ucyIsIm9uIiwiaW5mbGF0ZU9uRXJyb3IiLCJpbmZsYXRlT25EYXRhIiwid3JpdGUiLCJmbHVzaCIsImNvbmNhdCIsIl9yZWFkYWJsZVN0YXRlIiwiZW5kRW1pdHRlZCIsInJlc2V0IiwiY3JlYXRlRGVmbGF0ZVJhdyIsInpsaWJEZWZsYXRlT3B0aW9ucyIsImRlZmxhdGVPbkRhdGEiLCJaX1NZTkNfRkxVU0giLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwibW9kdWxlIiwiZXhwb3J0cyIsImNodW5rIiwicHVzaCIsIlJhbmdlRXJyb3IiLCJjb2RlIiwicmVtb3ZlTGlzdGVuZXIiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  Writable\n} = __webpack_require__(/*! stream */ \"stream\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst {\n  concat,\n  toArrayBuffer,\n  unmask\n} = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ws/lib/buffer-util.js\");\nconst {\n  isValidStatusCode,\n  isValidUTF8\n} = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\nconst FastBuffer = Buffer[Symbol.species];\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n    this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._errored = false;\n    this._loop = false;\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n    if (n === this._buffers[0].length) return this._buffers.shift();\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n    const dst = Buffer.allocUnsafe(n);\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n      }\n      n -= buf.length;\n    } while (n > 0);\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    this._loop = true;\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64(cb);\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData(cb);\n          break;\n        case INFLATING:\n        case DEFER_EVENT:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n    if (!this._errored) cb();\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getInfo(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(2);\n    if ((buf[0] & 0x30) !== 0x00) {\n      const error = this.createError(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');\n      cb(error);\n      return;\n    }\n    const compressed = (buf[0] & 0x40) === 0x40;\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n      cb(error);\n      return;\n    }\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n        cb(error);\n        return;\n      }\n      if (!this._fragmented) {\n        const error = this.createError(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');\n        cb(error);\n        return;\n      }\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n        cb(error);\n        return;\n      }\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        const error = this.createError(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');\n        cb(error);\n        return;\n      }\n      if (compressed) {\n        const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n        cb(error);\n        return;\n      }\n      if (this._payloadLength > 0x7d || this._opcode === 0x08 && this._payloadLength === 1) {\n        const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n        cb(error);\n        return;\n      }\n    } else {\n      const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n      cb(error);\n      return;\n    }\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n    if (this._isServer) {\n      if (!this._masked) {\n        const error = this.createError(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');\n        cb(error);\n        return;\n      }\n    } else if (this._masked) {\n      const error = this.createError(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');\n      cb(error);\n      return;\n    }\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength16(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength64(cb) {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      const error = this.createError(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');\n      cb(error);\n      return;\n    }\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  haveLength(cb) {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n        cb(error);\n        return;\n      }\n    }\n    if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n      data = this.consume(this._payloadLength);\n      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n        unmask(data, this._mask);\n      }\n    }\n    if (this._opcode > 0x07) {\n      this.controlMessage(data, cb);\n      return;\n    }\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n    this.dataMessage(cb);\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n          cb(error);\n          return;\n        }\n        this._fragments.push(buf);\n      }\n      this.dataMessage(cb);\n      if (this._state === GET_INFO) this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  dataMessage(cb) {\n    if (!this._fin) {\n      this._state = GET_INFO;\n      return;\n    }\n    const messageLength = this._messageLength;\n    const fragments = this._fragments;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragmented = 0;\n    this._fragments = [];\n    if (this._opcode === 2) {\n      let data;\n      if (this._binaryType === 'nodebuffer') {\n        data = concat(fragments, messageLength);\n      } else if (this._binaryType === 'arraybuffer') {\n        data = toArrayBuffer(concat(fragments, messageLength));\n      } else if (this._binaryType === 'blob') {\n        data = new Blob(fragments);\n      } else {\n        data = fragments;\n      }\n      if (this._allowSynchronousEvents) {\n        this.emit('message', data, true);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', data, true);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    } else {\n      const buf = concat(fragments, messageLength);\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n        const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n        cb(error);\n        return;\n      }\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\n        this.emit('message', buf, false);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', buf, false);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data, cb) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this._loop = false;\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n        if (!isValidStatusCode(code)) {\n          const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');\n          cb(error);\n          return;\n        }\n        const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n          cb(error);\n          return;\n        }\n        this._loop = false;\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n      this._state = GET_INFO;\n      return;\n    }\n    if (this._allowSynchronousEvents) {\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n      this._state = GET_INFO;\n    } else {\n      this._state = DEFER_EVENT;\n      setImmediate(() => {\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n        this._state = GET_INFO;\n        this.startLoop(cb);\n      });\n    }\n  }\n\n  /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n    this._loop = false;\n    this._errored = true;\n    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n    Error.captureStackTrace(err, this.createError);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n  }\n}\nmodule.exports = Receiver;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLE1BQU07RUFBRUE7QUFBUyxDQUFDLEdBQUdDLG1CQUFPLENBQUMsc0JBQVEsQ0FBQztBQUV0QyxNQUFNQyxpQkFBaUIsR0FBR0QsbUJBQU8sQ0FBQywrRUFBc0IsQ0FBQztBQUN6RCxNQUFNO0VBQ0pFLFlBQVk7RUFDWkMsWUFBWTtFQUNaQyxXQUFXO0VBQ1hDO0FBQ0YsQ0FBQyxHQUFHTCxtQkFBTyxDQUFDLDZEQUFhLENBQUM7QUFDMUIsTUFBTTtFQUFFTSxNQUFNO0VBQUVDLGFBQWE7RUFBRUM7QUFBTyxDQUFDLEdBQUdSLG1CQUFPLENBQUMsaUVBQWUsQ0FBQztBQUNsRSxNQUFNO0VBQUVTLGlCQUFpQjtFQUFFQztBQUFZLENBQUMsR0FBR1YsbUJBQU8sQ0FBQywrREFBYyxDQUFDO0FBRWxFLE1BQU1XLFVBQVUsR0FBR0MsTUFBTSxDQUFDQyxNQUFNLENBQUNDLE9BQU8sQ0FBQztBQUV6QyxNQUFNQyxRQUFRLEdBQUcsQ0FBQztBQUNsQixNQUFNQyxxQkFBcUIsR0FBRyxDQUFDO0FBQy9CLE1BQU1DLHFCQUFxQixHQUFHLENBQUM7QUFDL0IsTUFBTUMsUUFBUSxHQUFHLENBQUM7QUFDbEIsTUFBTUMsUUFBUSxHQUFHLENBQUM7QUFDbEIsTUFBTUMsU0FBUyxHQUFHLENBQUM7QUFDbkIsTUFBTUMsV0FBVyxHQUFHLENBQUM7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxRQUFRLFNBQVN2QixRQUFRLENBQUM7RUFDOUI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRXdCLFdBQVdBLENBQUNDLE9BQU8sR0FBRyxDQUFDLENBQUMsRUFBRTtJQUN4QixLQUFLLENBQUMsQ0FBQztJQUVQLElBQUksQ0FBQ0MsdUJBQXVCLEdBQzFCRCxP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LENBQUNDLE9BQU8sR0FBR3RGLFFBQVEiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSLFxuICBrU3RhdHVzQ29kZSxcbiAga1dlYlNvY2tldFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGNvbmNhdCwgdG9BcnJheUJ1ZmZlciwgdW5tYXNrIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCB7IGlzVmFsaWRTdGF0dXNDb2RlLCBpc1ZhbGlkVVRGOCB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuXG5jb25zdCBHRVRfSU5GTyA9IDA7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzY0ID0gMjtcbmNvbnN0IEdFVF9NQVNLID0gMztcbmNvbnN0IEdFVF9EQVRBID0gNDtcbmNvbnN0IElORkxBVElORyA9IDU7XG5jb25zdCBERUZFUl9FVkVOVCA9IDY7XG5cbi8qKlxuICogSHlCaSBSZWNlaXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBXcml0YWJsZVxuICovXG5jbGFzcyBSZWNlaXZlciBleHRlbmRzIFdyaXRhYmxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWNlaXZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXJcbiAgICogICAgIGFueSBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5iaW5hcnlUeXBlPW5vZGVidWZmZXJdIFRoZSB0eXBlIGZvciBiaW5hcnkgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWRcbiAgICogICAgIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1NlcnZlcj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdG8gb3BlcmF0ZSBpblxuICAgKiAgICAgY2xpZW50IG9yIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMgPVxuICAgICAgb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHNcbiAgICAgICAgOiB0cnVlO1xuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBvcHRpb25zLmJpbmFyeVR5cGUgfHwgQklOQVJZX1RZUEVTWzBdO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBvcHRpb25zLmV4dGVuc2lvbnMgfHwge307XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIW9wdGlvbnMuaXNTZXJ2ZXI7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG9wdGlvbnMubWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uID0gISFvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbjtcbiAgICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fYnVmZmVycyA9IFtdO1xuXG4gICAgdGhpcy5fY29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21hc2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgdGhpcy5fbWFza2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZmluID0gZmFsc2U7XG4gICAgdGhpcy5fb3Bjb2RlID0gMDtcblxuICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cbiAgICB0aGlzLl9lcnJvcmVkID0gZmFsc2U7XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyBgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIFRoZSBjaHVuayBvZiBkYXRhIHRvIHdyaXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIGBjaHVua2BcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9zdGF0ZSA9PSBHRVRfSU5GTykgcmV0dXJuIGNiKCk7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLl9idWZmZXJzLnB1c2goY2h1bmspO1xuICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lcyBgbmAgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBieXRlcyB0byBjb25zdW1lXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGNvbnN1bWVkIGJ5dGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdW1lKG4pIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG47XG5cbiAgICBpZiAobiA9PT0gdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHJldHVybiB0aGlzLl9idWZmZXJzLnNoaWZ0KCk7XG5cbiAgICBpZiAobiA8IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICBidWYuYnVmZmVyLFxuICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXG4gICAgICAgIGJ1Zi5sZW5ndGggLSBuXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pO1xuICAgIH1cblxuICAgIGNvbnN0IGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICBjb25zdCBvZmZzZXQgPSBkc3QubGVuZ3RoIC0gbjtcblxuICAgICAgaWYgKG4gPj0gYnVmLmxlbmd0aCkge1xuICAgICAgICBkc3Quc2V0KHRoaXMuX2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRzdC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJzWzBdID0gbmV3IEZhc3RCdWZmZXIoXG4gICAgICAgICAgYnVmLmJ1ZmZlcixcbiAgICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXG4gICAgICAgICAgYnVmLmxlbmd0aCAtIG5cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbiAtPSBidWYubGVuZ3RoO1xuICAgIH0gd2hpbGUgKG4gPiAwKTtcblxuICAgIHJldHVybiBkc3Q7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBwYXJzaW5nIGxvb3AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydExvb3AoY2IpIHtcbiAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgY2FzZSBHRVRfSU5GTzpcbiAgICAgICAgICB0aGlzLmdldEluZm8oY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF8xNjpcbiAgICAgICAgICB0aGlzLmdldFBheWxvYWRMZW5ndGgxNihjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzY0OlxuICAgICAgICAgIHRoaXMuZ2V0UGF5bG9hZExlbmd0aDY0KGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfTUFTSzpcbiAgICAgICAgICB0aGlzLmdldE1hc2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfREFUQTpcbiAgICAgICAgICB0aGlzLmdldERhdGEoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIElORkxBVElORzpcbiAgICAgICAgY2FzZSBERUZFUl9FVkVOVDpcbiAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRoaXMuX2xvb3ApO1xuXG4gICAgaWYgKCF0aGlzLl9lcnJvcmVkKSBjYigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBmaXJzdCB0d28gYnl0ZXMgb2YgYSBmcmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEluZm8oY2IpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoMik7XG5cbiAgICBpZiAoKGJ1ZlswXSAmIDB4MzApICE9PSAweDAwKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YyIGFuZCBSU1YzIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzJfMydcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xuXG4gICAgaWYgKGNvbXByZXNzZWQgJiYgIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9maW4gPSAoYnVmWzBdICYgMHg4MCkgPT09IDB4ODA7XG4gICAgdGhpcy5fb3Bjb2RlID0gYnVmWzBdICYgMHgwZjtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gYnVmWzFdICYgMHg3ZjtcblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDApIHtcbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBvcGNvZGUgMCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29wY29kZSA9IHRoaXMuX2ZyYWdtZW50ZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDEgfHwgdGhpcy5fb3Bjb2RlID09PSAweDAyKSB7XG4gICAgICBpZiAodGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29tcHJlc3NlZCA9IGNvbXByZXNzZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3ICYmIHRoaXMuX29wY29kZSA8IDB4MGIpIHtcbiAgICAgIGlmICghdGhpcy5fZmluKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdGSU4gbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX0ZJTidcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID4gMHg3ZCB8fFxuICAgICAgICAodGhpcy5fb3Bjb2RlID09PSAweDA4ICYmIHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgcGF5bG9hZCBsZW5ndGggJHt0aGlzLl9wYXlsb2FkTGVuZ3RofWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9DT05UUk9MX1BBWUxPQURfTEVOR1RIJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xuICAgIHRoaXMuX21hc2tlZCA9IChidWZbMV0gJiAweDgwKSA9PT0gMHg4MDtcblxuICAgIGlmICh0aGlzLl9pc1NlcnZlcikge1xuICAgICAgaWYgKCF0aGlzLl9tYXNrZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ01BU0sgbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX01BU0snXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9tYXNrZWQpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ01BU0sgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9NQVNLJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjYpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzE2O1xuICAgIGVsc2UgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNykgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ7XG4gICAgZWxzZSB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrMTYpLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDE2KGNiKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMuY29uc3VtZSgyKS5yZWFkVUludDE2QkUoMCk7XG4gICAgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzY0KS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGg2NChjYikge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgOCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSg4KTtcbiAgICBjb25zdCBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgbWF4aW11bSBzYWZlIGludGVnZXIgaW4gSmF2YVNjcmlwdCBpcyAyXjUzIC0gMS4gQW4gZXJyb3IgaXMgcmV0dXJuZWRcbiAgICAvLyBpZiBwYXlsb2FkIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhpcyBudW1iZXIuXG4gICAgLy9cbiAgICBpZiAobnVtID4gTWF0aC5wb3coMiwgNTMgLSAzMikgLSAxKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdVbnN1cHBvcnRlZCBXZWJTb2NrZXQgZnJhbWU6IHBheWxvYWQgbGVuZ3RoID4gMl41MyAtIDEnLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgMTAwOSxcbiAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9EQVRBX1BBWUxPQURfTEVOR1RIJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBudW0gKiBNYXRoLnBvdygyLCAzMikgKyBidWYucmVhZFVJbnQzMkJFKDQpO1xuICAgIHRoaXMuaGF2ZUxlbmd0aChjYik7XG4gIH1cblxuICAvKipcbiAgICogUGF5bG9hZCBsZW5ndGggaGFzIGJlZW4gcmVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhdmVMZW5ndGgoY2IpIHtcbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCAmJiB0aGlzLl9vcGNvZGUgPCAweDA4KSB7XG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggKz0gdGhpcy5fcGF5bG9hZExlbmd0aDtcbiAgICAgIGlmICh0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAxMDA5LFxuICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hc2tlZCkgdGhpcy5fc3RhdGUgPSBHRVRfTUFTSztcbiAgICBlbHNlIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgbWFzayBieXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1hc2soKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA0KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbWFzayA9IHRoaXMuY29uc3VtZSg0KTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGRhdGEgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXREYXRhKGNiKSB7XG4gICAgbGV0IGRhdGEgPSBFTVBUWV9CVUZGRVI7XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCB0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhID0gdGhpcy5jb25zdW1lKHRoaXMuX3BheWxvYWRMZW5ndGgpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX21hc2tlZCAmJlxuICAgICAgICAodGhpcy5fbWFza1swXSB8IHRoaXMuX21hc2tbMV0gfCB0aGlzLl9tYXNrWzJdIHwgdGhpcy5fbWFza1szXSkgIT09IDBcbiAgICAgICkge1xuICAgICAgICB1bm1hc2soZGF0YSwgdGhpcy5fbWFzayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHtcbiAgICAgIHRoaXMuY29udHJvbE1lc3NhZ2UoZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb21wcmVzc2VkKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IElORkxBVElORztcbiAgICAgIHRoaXMuZGVjb21wcmVzcyhkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBtZXNzYWdlIGlzIG5vdCBjb21wcmVzc2VkIHNvIGl0cyBsZW5ndGggaXMgdGhlIHN1bSBvZiB0aGUgcGF5bG9hZFxuICAgICAgLy8gbGVuZ3RoIG9mIGFsbCBmcmFnbWVudHMuXG4gICAgICAvL1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YU1lc3NhZ2UoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3NlcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5kZWNvbXByZXNzKGRhdGEsIHRoaXMuX2ZpbiwgKGVyciwgYnVmKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgaWYgKGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fbWVzc2FnZUxlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICAgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAxMDA5LFxuICAgICAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YU1lc3NhZ2UoY2IpO1xuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBHRVRfSU5GTykgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkYXRhTWVzc2FnZShjYikge1xuICAgIGlmICghdGhpcy5fZmluKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2VMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoO1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IHRoaXMuX2ZyYWdtZW50cztcblxuICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAyKSB7XG4gICAgICBsZXQgZGF0YTtcblxuICAgICAgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdub2RlYnVmZmVyJykge1xuICAgICAgICBkYXRhID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgZGF0YSA9IHRvQXJyYXlCdWZmZXIoY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBCbG9iKGZyYWdtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gZnJhZ21lbnRzO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gREVGRVJfRVZFTlQ7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBidWYgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcblxuICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIEVycm9yLFxuICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDcsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gSU5GTEFUSU5HIHx8IHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGNvbnRyb2wgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBoYW5kbGVcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udHJvbE1lc3NhZ2UoZGF0YSwgY2IpIHtcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4KSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgMTAwNSwgRU1QVFlfQlVGRkVSKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBkYXRhLnJlYWRVSW50MTZCRSgwKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAgIGBpbnZhbGlkIHN0YXR1cyBjb2RlICR7Y29kZX1gLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfQ0xPU0VfQ09ERSdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICAgIGRhdGEuYnVmZmVyLFxuICAgICAgICAgIGRhdGEuYnl0ZU9mZnNldCArIDIsXG4gICAgICAgICAgZGF0YS5sZW5ndGggLSAyXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCBjb2RlLCBidWYpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG4gICAgICB0aGlzLmVtaXQodGhpcy5fb3Bjb2RlID09PSAweDA5ID8gJ3BpbmcnIDogJ3BvbmcnLCBkYXRhKTtcbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gREVGRVJfRVZFTlQ7XG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5fb3Bjb2RlID09PSAweDA5ID8gJ3BpbmcnIDogJ3BvbmcnLCBkYXRhKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhbiBlcnJvciBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OkVycm9yfFJhbmdlRXJyb3IpfSBFcnJvckN0b3IgVGhlIGVycm9yIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZml4IFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBhZGQgYSBkZWZhdWx0IHByZWZpeCB0b1xuICAgKiAgICAgYG1lc3NhZ2VgXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBzdGF0dXMgY29kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXJyb3JDb2RlIFRoZSBleHBvc2VkIGVycm9yIGNvZGVcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3IpfSBUaGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZUVycm9yKEVycm9yQ3RvciwgbWVzc2FnZSwgcHJlZml4LCBzdGF0dXNDb2RlLCBlcnJvckNvZGUpIHtcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgdGhpcy5fZXJyb3JlZCA9IHRydWU7XG5cbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxuICAgICAgcHJlZml4ID8gYEludmFsaWQgV2ViU29ja2V0IGZyYW1lOiAke21lc3NhZ2V9YCA6IG1lc3NhZ2VcbiAgICApO1xuXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCB0aGlzLmNyZWF0ZUVycm9yKTtcbiAgICBlcnIuY29kZSA9IGVycm9yQ29kZTtcbiAgICBlcnJba1N0YXR1c0NvZGVdID0gc3RhdHVzQ29kZTtcbiAgICByZXR1cm4gZXJyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVjZWl2ZXI7XG4iXSwibmFtZXMiOlsiV3JpdGFibGUiLCJyZXF1aXJlIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJCSU5BUllfVFlQRVMiLCJFTVBUWV9CVUZGRVIiLCJrU3RhdHVzQ29kZSIsImtXZWJTb2NrZXQiLCJjb25jYXQiLCJ0b0FycmF5QnVmZmVyIiwidW5tYXNrIiwiaXNWYWxpZFN0YXR1c0NvZGUiLCJpc1ZhbGlkVVRGOCIsIkZhc3RCdWZmZXIiLCJCdWZmZXIiLCJTeW1ib2wiLCJzcGVjaWVzIiwiR0VUX0lORk8iLCJHRVRfUEFZTE9BRF9MRU5HVEhfMTYiLCJHRVRfUEFZTE9BRF9MRU5HVEhfNjQiLCJHRVRfTUFTSyIsIkdFVF9EQVRBIiwiSU5GTEFUSU5HIiwiREVGRVJfRVZFTlQiLCJSZWNlaXZlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzIiwiYWxsb3dTeW5jaHJvbm91c0V2ZW50cyIsInVuZGVmaW5lZCIsIl9iaW5hcnlUeXBlIiwiYmluYXJ5VHlwZSIsIl9leHRlbnNpb25zIiwiZXh0ZW5zaW9ucyIsIl9pc1NlcnZlciIsImlzU2VydmVyIiwiX21heFBheWxvYWQiLCJtYXhQYXlsb2FkIiwiX3NraXBVVEY4VmFsaWRhdGlvbiIsInNraXBVVEY4VmFsaWRhdGlvbiIsIl9idWZmZXJlZEJ5dGVzIiwiX2J1ZmZlcnMiLCJfY29tcHJlc3NlZCIsIl9wYXlsb2FkTGVuZ3RoIiwiX21hc2siLCJfZnJhZ21lbnRlZCIsIl9tYXNrZWQiLCJfZmluIiwiX29wY29kZSIsIl90b3RhbFBheWxvYWRMZW5ndGgiLCJfbWVzc2FnZUxlbmd0aCIsIl9mcmFnbWVudHMiLCJfZXJyb3JlZCIsIl9sb29wIiwiX3N0YXRlIiwiX3dyaXRlIiwiY2h1bmsiLCJlbmNvZGluZyIsImNiIiwibGVuZ3RoIiwicHVzaCIsInN0YXJ0TG9vcCIsImNvbnN1bWUiLCJuIiwic2hpZnQiLCJidWYiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiZHN0IiwiYWxsb2NVbnNhZmUiLCJvZmZzZXQiLCJzZXQiLCJVaW50OEFycmF5IiwiZ2V0SW5mbyIsImdldFBheWxvYWRMZW5ndGgxNiIsImdldFBheWxvYWRMZW5ndGg2NCIsImdldE1hc2siLCJnZXREYXRhIiwiZXJyb3IiLCJjcmVhdGVFcnJvciIsIlJhbmdlRXJyb3IiLCJjb21wcmVzc2VkIiwiZXh0ZW5zaW9uTmFtZSIsImhhdmVMZW5ndGgiLCJyZWFkVUludDE2QkUiLCJudW0iLCJyZWFkVUludDMyQkUiLCJNYXRoIiwicG93IiwiZGF0YSIsImNvbnRyb2xNZXNzYWdlIiwiZGVjb21wcmVzcyIsImRhdGFNZXNzYWdlIiwicGVyTWVzc2FnZURlZmxhdGUiLCJlcnIiLCJtZXNzYWdlTGVuZ3RoIiwiZnJhZ21lbnRzIiwiQmxvYiIsImVtaXQiLCJzZXRJbW1lZGlhdGUiLCJFcnJvciIsImVuZCIsImNvZGUiLCJFcnJvckN0b3IiLCJtZXNzYWdlIiwicHJlZml4Iiwic3RhdHVzQ29kZSIsImVycm9yQ29kZSIsImNhcHR1cmVTdGFja1RyYWNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */ \nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ws/lib/buffer-util.js\");\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n/**\n * HyBi Sender implementation.\n */ class Sender {\n    /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */ constructor(socket, extensions, generateMask){\n        this._extensions = extensions || {};\n        if (generateMask) {\n            this._generateMask = generateMask;\n            this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._queue = [];\n        this._state = DEFAULT;\n        this.onerror = NOOP;\n        this[kWebSocket] = undefined;\n    }\n    /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */ static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n            mask = options.maskBuffer || maskBuffer;\n            if (options.generateMask) {\n                options.generateMask(mask);\n            } else {\n                if (randomPoolPointer === RANDOM_POOL_SIZE) {\n                    /* istanbul ignore else  */ if (randomPool === undefined) {\n                        //\n                        // This is lazily initialized because server-sent frames must not\n                        // be masked so it may never be used.\n                        //\n                        randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n                    }\n                    randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n                    randomPoolPointer = 0;\n                }\n                mask[0] = randomPool[randomPoolPointer++];\n                mask[1] = randomPool[randomPoolPointer++];\n                mask[2] = randomPool[randomPoolPointer++];\n                mask[3] = randomPool[randomPoolPointer++];\n            }\n            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n            offset = 6;\n        }\n        let dataLength;\n        if (typeof data === 'string') {\n            if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                dataLength = options[kByteLength];\n            } else {\n                data = Buffer.from(data);\n                dataLength = data.length;\n            }\n        } else {\n            dataLength = data.length;\n            merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (dataLength > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n            target[2] = target[3] = 0;\n            target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [\n            target,\n            data\n        ];\n        target[1] |= 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [\n            target,\n            data\n        ];\n        if (merge) {\n            applyMask(data, mask, target, offset, dataLength);\n            return [\n                target\n            ];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */ close(code, data, mask, cb) {\n        let buf;\n        if (code === undefined) {\n            buf = EMPTY_BUFFER;\n        } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n            throw new TypeError('First argument must be a valid error code number');\n        } else if (data === undefined || !data.length) {\n            buf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(code, 0);\n        } else {\n            const length = Buffer.byteLength(data);\n            if (length > 123) {\n                throw new RangeError('The message must not be greater than 123 bytes');\n            }\n            buf = Buffer.allocUnsafe(2 + length);\n            buf.writeUInt16BE(code, 0);\n            if (typeof data === 'string') {\n                buf.write(data, 2);\n            } else {\n                buf.set(data, 2);\n            }\n        }\n        const options = {\n            [kByteLength]: buf.length,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x08,\n            readOnly: false,\n            rsv1: false\n        };\n        if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                buf,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(buf, options), cb);\n        }\n    }\n    /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError('The data size must not be greater than 125 bytes');\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x09,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError('The data size must not be greater than 125 bytes');\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x0a,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {\n                rsv1 = byteLength >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        const opts = {\n            [kByteLength]: byteLength,\n            fin: options.fin,\n            generateMask: this._generateMask,\n            mask: options.mask,\n            maskBuffer: this._maskBuffer,\n            opcode,\n            readOnly,\n            rsv1\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, this._compress, opts, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                this._compress,\n                opts,\n                cb\n            ]);\n        } else {\n            this.dispatch(data, this._compress, opts, cb);\n        }\n    }\n    /**\n   * Gets the contents of a blob as binary data.\n   *\n   * @param {Blob} blob The blob\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     the data\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ getBlobData(blob, compress, options, cb) {\n        this._bufferedBytes += options[kByteLength];\n        this._state = GET_BLOB_DATA;\n        blob.arrayBuffer().then((arrayBuffer)=>{\n            if (this._socket.destroyed) {\n                const err = new Error('The socket was closed while the blob was being read');\n                //\n                // `callCallbacks` is called in the next tick to ensure that errors\n                // that might be thrown in the callbacks behave like errors thrown\n                // outside the promise chain.\n                //\n                process.nextTick(callCallbacks, this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            const data = toBuffer(arrayBuffer);\n            if (!compress) {\n                this._state = DEFAULT;\n                this.sendFrame(Sender.frame(data, options), cb);\n                this.dequeue();\n            } else {\n                this.dispatch(data, compress, options, cb);\n            }\n        }).catch((err)=>{\n            //\n            // `onError` is called in the next tick for the same reason that\n            // `callCallbacks` above is.\n            //\n            process.nextTick(onError, this, err, cb);\n        });\n    }\n    /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._state = DEFLATING;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            if (this._socket.destroyed) {\n                const err = new Error('The socket was closed while data was being compressed');\n                callCallbacks(this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            this._state = DEFAULT;\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this.dequeue();\n        });\n    }\n    /**\n   * Executes queued send operations.\n   *\n   * @private\n   */ dequeue() {\n        while(this._state === DEFAULT && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[3][kByteLength];\n            Reflect.apply(params[0], this, params.slice(1));\n        }\n    }\n    /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */ enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n    }\n    /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.cork();\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n            this._socket.uncork();\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n/**\n * Calls queued callbacks with an error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error to call the callbacks with\n * @param {Function} [cb] The first callback\n * @private\n */ function callCallbacks(sender, err, cb) {\n    if (typeof cb === 'function') cb(err);\n    for(let i = 0; i < sender._queue.length; i++){\n        const params = sender._queue[i];\n        const callback = params[params.length - 1];\n        if (typeof callback === 'function') callback(err);\n    }\n}\n/**\n * Handles a `Sender` error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error\n * @param {Function} [cb] The first pending callback\n * @private\n */ function onError(sender, err, cb) {\n    callCallbacks(sender, err, cb);\n    sender.onerror(err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyRUFFYTtBQUViLE1BQU0sRUFBRUEsTUFBQUEsRUFBUSxHQUFHQyxtQkFBTyxDQUFDLHNCQUFRLENBQUM7QUFDcEMsTUFBTSxFQUFFQyxjQUFBQSxFQUFnQixHQUFHRCxtQkFBTyxDQUFDLHNCQUFRLENBQUM7QUFFNUMsTUFBTUUsaUJBQWlCLEdBQUdGLG1CQUFPLENBQUMsK0VBQXNCLENBQUM7QUFDekQsTUFBTSxFQUFFRyxZQUFZLEVBQUVDLFVBQVUsRUFBRUMsSUFBQUEsRUFBTSxHQUFHTCxtQkFBTyxDQUFDLDZEQUFhLENBQUM7QUFDakUsTUFBTSxFQUFFTSxNQUFNLEVBQUVDLGlCQUFBQSxFQUFtQixHQUFHUCxtQkFBTyxDQUFDLCtEQUFjLENBQUM7QUFDN0QsTUFBTSxFQUFFUSxJQUFJLEVBQUVDLFNBQVMsRUFBRUMsUUFBQUEsRUFBVSxHQUFHVixtQkFBTyxDQUFDLGlFQUFlLENBQUM7QUFFOUQsTUFBTVcsV0FBVyxHQUFHQyxNQUFNLENBQUMsYUFBYSxDQUFDO0FBQ3pDLE1BQU1DLFVBQVUsR0FBR0MsTUFBTSxDQUFDQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQ2xDLE1BQU1DLGdCQUFnQixHQUFHLENBQUMsR0FBRyxJQUFJO0FBQ2pDLElBQUlDLFVBQVU7QUFDZCxJQUFJQyxpQkFBaUIsR0FBR0YsZ0JBQWdCO0FBRXhDLE1BQU1HLE9BQU8sR0FBRyxDQUFDO0FBQ2pCLE1BQU1DLFNBQVMsR0FBRyxDQUFDO0FBQ25CLE1BQU1DLGFBQWEsR0FBRyxDQUFDO0FBRXZCOztDQUVBLEdBQ0EsTUFBTUMsTUFBTSxDQUFDO0lBQ1g7Ozs7Ozs7R0FPRixHQUNFQyxXQUFXQSxDQUFDQyxNQUFNLEVBQUVDLFVBQVUsRUFBRUMsWUFBWSxDQUFFO1FBQzVDLElBQUksQ0FBQ0MsV0FBVyxHQUFHRixVQUFVLElBQUksQ0FBQyxDQUFDO1FBRW5DLElBQUlDLFlBQVksRUFB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bWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXhcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcmFuZG9tRmlsbFN5bmMgfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCB7IEVNUFRZX0JVRkZFUiwga1dlYlNvY2tldCwgTk9PUCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgaXNCbG9iLCBpc1ZhbGlkU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5jb25zdCB7IG1hc2s6IGFwcGx5TWFzaywgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3Qga0J5dGVMZW5ndGggPSBTeW1ib2woJ2tCeXRlTGVuZ3RoJyk7XG5jb25zdCBtYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuY29uc3QgUkFORE9NX1BPT0xfU0laRSA9IDggKiAxMDI0O1xubGV0IHJhbmRvbVBvb2w7XG5sZXQgcmFuZG9tUG9vbFBvaW50ZXIgPSBSQU5ET01fUE9PTF9TSVpFO1xuXG5jb25zdCBERUZBVUxUID0gMDtcbmNvbnN0IERFRkxBVElORyA9IDE7XG5jb25zdCBHRVRfQkxPQl9EQVRBID0gMjtcblxuLyoqXG4gKiBIeUJpIFNlbmRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgU2VuZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTZW5kZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIGNvbm5lY3Rpb24gc29ja2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb2NrZXQsIGV4dGVuc2lvbnMsIGdlbmVyYXRlTWFzaykge1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xuXG4gICAgaWYgKGdlbmVyYXRlTWFzaykge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVNYXNrID0gZ2VuZXJhdGVNYXNrO1xuICAgICAgdGhpcy5fbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21wcmVzcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB0aGlzLl9zdGF0ZSA9IERFRkFVTFQ7XG4gICAgdGhpcy5vbmVycm9yID0gTk9PUDtcbiAgICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhIHBpZWNlIG9mIGRhdGEgYWNjb3JkaW5nIHRvIHRoZSBIeUJpIFdlYlNvY2tldCBwcm90b2NvbC5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIGRhdGEgdG8gZnJhbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEByZXR1cm4geyhCdWZmZXJ8U3RyaW5nKVtdfSBUaGUgZnJhbWVkIGRhdGFcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc3RhdGljIGZyYW1lKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFzaztcbiAgICBsZXQgbWVyZ2UgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICBsZXQgc2tpcE1hc2tpbmcgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLm1hc2spIHtcbiAgICAgIG1hc2sgPSBvcHRpb25zLm1hc2tCdWZmZXIgfHwgbWFza0J1ZmZlcjtcblxuICAgICAgaWYgKG9wdGlvbnMuZ2VuZXJhdGVNYXNrKSB7XG4gICAgICAgIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKG1hc2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJhbmRvbVBvb2xQb2ludGVyID09PSBSQU5ET01fUE9PTF9TSVpFKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG4gICAgICAgICAgaWYgKHJhbmRvbVBvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbGF6aWx5IGluaXRpYWxpemVkIGJlY2F1c2Ugc2VydmVyLXNlbnQgZnJhbWVzIG11c3Qgbm90XG4gICAgICAgICAgICAvLyBiZSBtYXNrZWQgc28gaXQgbWF5IG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgcmFuZG9tUG9vbCA9IEJ1ZmZlci5hbGxvYyhSQU5ET01fUE9PTF9TSVpFKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByYW5kb21GaWxsU3luYyhyYW5kb21Qb29sLCAwLCBSQU5ET01fUE9PTF9TSVpFKTtcbiAgICAgICAgICByYW5kb21Qb29sUG9pbnRlciA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBtYXNrWzBdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgICAgbWFza1sxXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICAgIG1hc2tbMl0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgICBtYXNrWzNdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgIH1cblxuICAgICAgc2tpcE1hc2tpbmcgPSAobWFza1swXSB8IG1hc2tbMV0gfCBtYXNrWzJdIHwgbWFza1szXSkgPT09IDA7XG4gICAgICBvZmZzZXQgPSA2O1xuICAgIH1cblxuICAgIGxldCBkYXRhTGVuZ3RoO1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKFxuICAgICAgICAoIW9wdGlvbnMubWFzayB8fCBza2lwTWFza2luZykgJiZcbiAgICAgICAgb3B0aW9uc1trQnl0ZUxlbmd0aF0gIT09IHVuZGVmaW5lZFxuICAgICAgKSB7XG4gICAgICAgIGRhdGFMZW5ndGggPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICBtZXJnZSA9IG9wdGlvbnMubWFzayAmJiBvcHRpb25zLnJlYWRPbmx5ICYmICFza2lwTWFza2luZztcbiAgICB9XG5cbiAgICBsZXQgcGF5bG9hZExlbmd0aCA9IGRhdGFMZW5ndGg7XG5cbiAgICBpZiAoZGF0YUxlbmd0aCA+PSA2NTUzNikge1xuICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3O1xuICAgIH0gZWxzZSBpZiAoZGF0YUxlbmd0aCA+IDEyNSkge1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2O1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXJnZSA/IGRhdGFMZW5ndGggKyBvZmZzZXQgOiBvZmZzZXQpO1xuXG4gICAgdGFyZ2V0WzBdID0gb3B0aW9ucy5maW4gPyBvcHRpb25zLm9wY29kZSB8IDB4ODAgOiBvcHRpb25zLm9wY29kZTtcbiAgICBpZiAob3B0aW9ucy5yc3YxKSB0YXJnZXRbMF0gfD0gMHg0MDtcblxuICAgIHRhcmdldFsxXSA9IHBheWxvYWRMZW5ndGg7XG5cbiAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MTZCRShkYXRhTGVuZ3RoLCAyKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgdGFyZ2V0WzJdID0gdGFyZ2V0WzNdID0gMDtcbiAgICAgIHRhcmdldC53cml0ZVVJbnRCRShkYXRhTGVuZ3RoLCA0LCA2KTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMubWFzaykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuXG4gICAgdGFyZ2V0WzFdIHw9IDB4ODA7XG4gICAgdGFyZ2V0W29mZnNldCAtIDRdID0gbWFza1swXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gM10gPSBtYXNrWzFdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAyXSA9IG1hc2tbMl07XG4gICAgdGFyZ2V0W29mZnNldCAtIDFdID0gbWFza1szXTtcblxuICAgIGlmIChza2lwTWFza2luZykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuXG4gICAgaWYgKG1lcmdlKSB7XG4gICAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgdGFyZ2V0LCBvZmZzZXQsIGRhdGFMZW5ndGgpO1xuICAgICAgcmV0dXJuIFt0YXJnZXRdO1xuICAgIH1cblxuICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCBkYXRhLCAwLCBkYXRhTGVuZ3RoKTtcbiAgICByZXR1cm4gW3RhcmdldCwgZGF0YV07XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBjbG9zZSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFRoZSBzdGF0dXMgY29kZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgbWVzc2FnZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBidWY7XG5cbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBidWYgPSBFTVBUWV9CVUZGRVI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdmFsaWQgZXJyb3IgY29kZSBudW1iZXInKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEyMykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIG1lc3NhZ2UgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyMyBieXRlcycpO1xuICAgICAgfVxuXG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIGxlbmd0aCk7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcblxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBidWYud3JpdGUoZGF0YSwgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYuc2V0KGRhdGEsIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBidWYubGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogMHgwOCxcbiAgICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBidWYsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBpbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDA5LFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0QmxvYkRhdGEoZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwb25nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcbiAgICB9XG5cbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDEyNSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogMHgwYSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5nZXRCbG9iRGF0YSwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZGF0YSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeVxuICAgKiAgICAgb3IgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIGNvbXByZXNzIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZVxuICAgKiAgICAgbGFzdCBvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcbiAgICBsZXQgb3Bjb2RlID0gb3B0aW9ucy5iaW5hcnkgPyAyIDogMTtcbiAgICBsZXQgcnN2MSA9IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmlyc3RGcmFnbWVudCkge1xuICAgICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IGZhbHNlO1xuICAgICAgaWYgKFxuICAgICAgICByc3YxICYmXG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLnBhcmFtc1tcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5faXNTZXJ2ZXJcbiAgICAgICAgICAgID8gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICAgICAgOiAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgIF1cbiAgICAgICkge1xuICAgICAgICByc3YxID0gYnl0ZUxlbmd0aCA+PSBwZXJNZXNzYWdlRGVmbGF0ZS5fdGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tcHJlc3MgPSByc3YxO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3YxID0gZmFsc2U7XG4gICAgICBvcGNvZGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZpbikgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGUsXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjFcbiAgICB9O1xuXG4gICAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5nZXRCbG9iRGF0YSwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwYXRjaChkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjb250ZW50cyBvZiBhIGJsb2IgYXMgYmluYXJ5IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvYn0gYmxvYiBUaGUgYmxvYlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICB0aGUgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0QmxvYkRhdGEoYmxvYiwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9CTE9CX0RBVEE7XG5cbiAgICBibG9iXG4gICAgICAuYXJyYXlCdWZmZXIoKVxuICAgICAgLnRoZW4oKGFycmF5QnVmZmVyKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBzb2NrZXQgd2FzIGNsb3NlZCB3aGlsZSB0aGUgYmxvYiB3YXMgYmVpbmcgcmVhZCdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBgY2FsbENhbGxiYWNrc2AgaXMgY2FsbGVkIGluIHRoZSBuZXh0IHRpY2sgdG8gZW5zdXJlIHRoYXQgZXJyb3JzXG4gICAgICAgICAgLy8gdGhhdCBtaWdodCBiZSB0aHJvd24gaW4gdGhlIGNhbGxiYWNrcyBiZWhhdmUgbGlrZSBlcnJvcnMgdGhyb3duXG4gICAgICAgICAgLy8gb3V0c2lkZSB0aGUgcHJvbWlzZSBjaGFpbi5cbiAgICAgICAgICAvL1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbENhbGxiYWNrcywgdGhpcywgZXJyLCBjYik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRvQnVmZmVyKGFycmF5QnVmZmVyKTtcblxuICAgICAgICBpZiAoIWNvbXByZXNzKSB7XG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuICAgICAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2goZGF0YSwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGBvbkVycm9yYCBpcyBjYWxsZWQgaW4gdGhlIG5leHQgdGljayBmb3IgdGhlIHNhbWUgcmVhc29uIHRoYXRcbiAgICAgICAgLy8gYGNhbGxDYWxsYmFja3NgIGFib3ZlIGlzLlxuICAgICAgICAvL1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG9uRXJyb3IsIHRoaXMsIGVyciwgY2IpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAoIWNvbXByZXNzKSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3N0YXRlID0gREVGTEFUSU5HO1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmNvbXByZXNzKGRhdGEsIG9wdGlvbnMuZmluLCAoXywgYnVmKSA9PiB7XG4gICAgICBpZiAodGhpcy5fc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1RoZSBzb2NrZXQgd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBjb21wcmVzc2VkJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNhbGxDYWxsYmFja3ModGhpcywgZXJyLCBjYik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcbiAgICAgIG9wdGlvbnMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBxdWV1ZWQgc2VuZCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVxdWV1ZSgpIHtcbiAgICB3aGlsZSAodGhpcy5fc3RhdGUgPT09IERFRkFVTFQgJiYgdGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XG4gICAgICBSZWZsZWN0LmFwcGx5KHBhcmFtc1swXSwgdGhpcywgcGFyYW1zLnNsaWNlKDEpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzZW5kIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIFNlbmQgb3BlcmF0aW9uIHBhcmFtZXRlcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbnF1ZXVlKHBhcmFtcykge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBmcmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJbXX0gbGlzdCBUaGUgZnJhbWUgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZW5kRnJhbWUobGlzdCwgY2IpIHtcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuX3NvY2tldC5jb3JrKCk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFsxXSwgY2IpO1xuICAgICAgdGhpcy5fc29ja2V0LnVuY29yaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlcjtcblxuLyoqXG4gKiBDYWxscyBxdWV1ZWQgY2FsbGJhY2tzIHdpdGggYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTZW5kZXJ9IHNlbmRlciBUaGUgYFNlbmRlcmAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3IgdG8gY2FsbCB0aGUgY2FsbGJhY2tzIHdpdGhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gVGhlIGZpcnN0IGNhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjYWxsQ2FsbGJhY2tzKHNlbmRlciwgZXJyLCBjYikge1xuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSBjYihlcnIpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VuZGVyLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5fcXVldWVbaV07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXMgYSBgU2VuZGVyYCBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1NlbmRlcn0gc2VuZGVyIFRoZSBgU2VuZGVyYCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBUaGUgZmlyc3QgcGVuZGluZyBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gb25FcnJvcihzZW5kZXIsIGVyciwgY2IpIHtcbiAgY2FsbENhbGxiYWNrcyhzZW5kZXIsIGVyciwgY2IpO1xuICBzZW5kZXIub25lcnJvcihlcnIpO1xufVxuIl0sIm5hbWVzIjpbIkR1cGxleCIsInJlcXVpcmUiLCJyYW5kb21GaWxsU3luYyIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiRU1QVFlfQlVGRkVSIiwia1dlYlNvY2tldCIsIk5PT1AiLCJpc0Jsb2IiLCJpc1ZhbGlkU3RhdHVzQ29kZSIsIm1hc2siLCJhcHBseU1hc2siLCJ0b0J1ZmZlciIsImtCeXRlTGVuZ3RoIiwiU3ltYm9sIiwibWFza0J1ZmZlciIsIkJ1ZmZlciIsImFsbG9jIiwiUkFORE9NX1BPT0xfU0laRSIsInJhbmRvbVBvb2wiLCJyYW5kb21Qb29sUG9pbnRlciIsIkRFRkFVTFQiLCJERUZMQVRJTkciLCJHRVRfQkxPQl9EQVRBIiwiU2VuZGVyIiwiY29uc3RydWN0b3IiLCJzb2NrZXQiLCJleHRlbnNpb25zIiwiZ2VuZXJhdGVNYXNrIiwiX2V4dGVuc2lvbnMiLCJfZ2VuZXJhdGVNYXNrIiwiX21hc2tCdWZmZXIiLCJfc29ja2V0IiwiX2ZpcnN0RnJhZ21lbnQiLCJfY29tcHJlc3MiLCJfYnVmZmVyZWRCeXRlcyIsIl9xdWV1ZSIsIl9zdGF0ZSIsIm9uZXJyb3IiLCJ1bmRlZmluZWQiLCJmcmFtZSIsImRhdGEiLCJvcHRpb25zIiwibWVyZ2UiLCJvZmZzZXQiLCJza2lwTWFza2luZyIsImRhdGFMZW5ndGgiLCJmcm9tIiwibGVuZ3RoIiwicmVhZE9ubHkiLCJwYXlsb2FkTGVuZ3RoIiwidGFyZ2V0IiwiYWxsb2NVbnNhZmUiLCJmaW4iLCJvcGNvZGUiLCJyc3YxIiwid3JpdGVVSW50MTZCRSIsIndyaXRlVUludEJFIiwiY2xvc2UiLCJjb2RlIiwiY2IiLCJidWYiLCJUeXBlRXJyb3IiLCJieXRlTGVuZ3RoIiwiUmFuZ2VFcnJvciIsIndyaXRlIiwic2V0IiwiZW5xdWV1ZSIsImRpc3BhdGNoIiwic2VuZEZyYW1lIiwicGluZyIsInNpemUiLCJnZXRCbG9iRGF0YSIsInBvbmciLCJzZW5kIiwicGVyTWVzc2FnZURlZmxhdGUiLCJleHRlbnNpb25OYW1lIiwiYmluYXJ5IiwiY29tcHJlc3MiLCJwYXJhbXMiLCJfaXNTZXJ2ZXIiLCJfdGhyZXNob2xkIiwib3B0cyIsImJsb2IiLCJhcnJheUJ1ZmZlciIsInRoZW4iLCJkZXN0cm95ZWQiLCJlcnIiLCJFcnJvciIsInByb2Nlc3MiLCJuZXh0VGljayIsImNhbGxDYWxsYmFja3MiLCJkZXF1ZXVlIiwiY2F0Y2giLCJvbkVycm9yIiwiXyIsInNoaWZ0IiwiUmVmbGVjdCIsImFwcGx5Iiwic2xpY2UiLCJwdXNoIiwibGlzdCIsImNvcmsiLCJ1bmNvcmsiLCJtb2R1bGUiLCJleHBvcnRzIiwic2VuZGVyIiwiaSIsImNhbGxiYWNrIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  Duplex\n} = __webpack_require__(/*! stream */ \"stream\");\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n  ws.on('message', function message(msg, isBinary) {\n    const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n    if (!duplex.push(data)) ws.pause();\n  });\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n    duplex.push(null);\n  });\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n    let called = false;\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n    if (terminateOnDestroy) ws.terminate();\n  };\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n    ws.send(chunk, callback);\n  };\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\nmodule.exports = createWebSocketStream;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixNQUFNO0VBQUVBO0FBQU8sQ0FBQyxHQUFHQyxtQkFBTyxDQUFDLHNCQUFRLENBQUM7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLFNBQVNBLENBQUNDLE1BQU0sRUFBRTtFQUN6QkEsTUFBTSxDQUFDQyxJQUFJLENBQUMsT0FBTyxDQUFDO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxXQUFXQSxDQUFBLEVBQUc7RUFDckIsSUFBSSxDQUFDLElBQUksQ0FBQ0MsU0FBUyxJQUFJLElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxRQUFRLEVBQUU7SUFDbkQsSUFBSSxDQUFDQyxPQUFPLENBQUMsQ0FBQztFQUNoQjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLGFBQWFBLENBQUNDLEdBQUcsRUFBRTtFQUMxQixJQUFJLENBQUNDLGNBQWMsQ0FBQyxPQUFPLEVBQUVGLGFBQWEsQ0FBQztFQUMzQyxJQUFJLENBQUNELE9BQU8sQ0FBQyxDQUFDO0VBQ2QsSUFBSSxJQUFJLENBQUNJLGFBQWEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDckM7SUFDQSxJQUFJLENBQUNULElBQUksQ0FBQyxPQUFPLEVBQUVPLEdBQUcsQ0FBQztFQUN6QjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTRyxxQkFBcUJBLENBQUNDLEVBQUUsRUFBRUMsT0FBTyxFQUFFO0VBQzFDLElBQUlDLGtCQUFrQixHQUFHLElBQUk7RUFFN0IsTUFBTUMsTUFBTSxHQUFHLElBQUlsQixNQUFNLENBQUM7SUFDeEIsR0FBR2dCLE9BQU87SUFDVkcsV0FBVyxFQUFFLEtBQUs7SUFDbEJqQixTQUFTLEVBQUUsS0FBSztJQUNoQmtCLFVBQVUs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LENBQUNkLElBQUksQ0FBQyxRQUFRLEVBQUUsU0FBU2dCLE1BQU1BLENBQUEsRUFBRztRQUMxQztRQUNBO1FBQ0E7UUFDQVosUUFBUSxDQUFDLENBQUM7TUFDWixDQUFDLENBQUM7TUFDRnBCLEVBQUUsQ0FBQ2tCLEtBQUssQ0FBQyxDQUFDO0lBQ1o7RUFDRixDQUFDO0VBRURmLE1BQU0sQ0FBQzhCLEtBQUssR0FBRyxZQUFZO0lBQ3pCLElBQUlqQyxFQUFFLENBQUNrQyxRQUFRLEVBQUVsQyxFQUFFLENBQUNtQyxNQUFNLENBQUMsQ0FBQztFQUM5QixDQUFDO0VBRURoQyxNQUFNLENBQUNpQyxNQUFNLEdBQUcsVUFBVUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVsQixRQUFRLEVBQUU7SUFDbkQsSUFBSXBCLEVBQUUsQ0FBQ3FCLFVBQVUsS0FBS3JCLEVBQUUsQ0FBQzRCLFVBQVUsRUFBRTtNQUNuQzVCLEVBQUUsQ0FBQ2dCLElBQUksQ0FBQyxNQUFNLEVBQUUsU0FBU2EsSUFBSUEsQ0FBQSxFQUFHO1FBQzlCMUIsTUFBTSxDQUFDaUMsTUFBTSxDQUFDQyxLQUFLLEVBQUVDLFFBQVEsRUFBRWxCLFFBQVEsQ0FBQztNQUMxQyxDQUFDLENBQUM7TUFDRjtJQUNGO0lBRUFwQixFQUFFLENBQUN1QyxJQUFJLENBQUNGLEtBQUssRUFBRWpCLFFBQVEsQ0FBQztFQUMxQixDQUFDO0VBRURqQixNQUFNLENBQUNJLEVBQUUsQ0FBQyxLQUFLLEVBQUVqQixXQUFXLENBQUM7RUFDN0JhLE1BQU0sQ0FBQ0ksRUFBRSxDQUFDLE9BQU8sRUFBRVosYUFBYSxDQUFDO0VBQ2pDLE9BQU9RLE1BQU07QUFDZjtBQUVBcUMsTUFBTSxDQUFDQyxPQUFPLEdBQUcxQyxxQkFBcUIiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3dzL2xpYi9zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qKlxuICogRW1pdHMgdGhlIGAnY2xvc2UnYCBldmVudCBvbiBhIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc3RyZWFtIFRoZSBzdHJlYW0uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVuZCgpIHtcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVycm9yKGVycikge1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IuXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwcyBhIGBXZWJTb2NrZXRgIGluIGEgZHVwbGV4IHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd3MgVGhlIGBXZWJTb2NrZXRgIHRvIHdyYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoZSBgRHVwbGV4YCBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7RHVwbGV4fSBUaGUgZHVwbGV4IHN0cmVhbVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRTdHJlYW0od3MsIG9wdGlvbnMpIHtcbiAgbGV0IHRlcm1pbmF0ZU9uRGVzdHJveSA9IHRydWU7XG5cbiAgY29uc3QgZHVwbGV4ID0gbmV3IER1cGxleCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBhdXRvRGVzdHJveTogZmFsc2UsXG4gICAgZW1pdENsb3NlOiBmYWxzZSxcbiAgICBvYmplY3RNb2RlOiBmYWxzZSxcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6IGZhbHNlXG4gIH0pO1xuXG4gIHdzLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gbWVzc2FnZShtc2csIGlzQmluYXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9XG4gICAgICAhaXNCaW5hcnkgJiYgZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgPyBtc2cudG9TdHJpbmcoKSA6IG1zZztcblxuICAgIGlmICghZHVwbGV4LnB1c2goZGF0YSkpIHdzLnBhdXNlKCk7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgYHdzLnRlcm1pbmF0ZSgpYCBmcm9tIGJlaW5nIGNhbGxlZCBieSBgZHVwbGV4Ll9kZXN0cm95KClgLlxuICAgIC8vXG4gICAgLy8gLSBJZiB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlIHRoZSBgJ29wZW4nYCBldmVudCwgdGhlblxuICAgIC8vICAgYHdzLnRlcm1pbmF0ZSgpYCBpcyBhIG5vb3AgYXMgbm8gc29ja2V0IGlzIGFzc2lnbmVkLlxuICAgIC8vIC0gT3RoZXJ3aXNlLCB0aGUgZXJyb3IgaXMgcmUtZW1pdHRlZCBieSB0aGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYFxuICAgIC8vICAgZXZlbnQgb2YgdGhlIGBSZWNlaXZlcmAgb2JqZWN0LiBUaGUgbGlzdGVuZXIgYWxyZWFkeSBjbG9zZXMgdGhlXG4gICAgLy8gICBjb25uZWN0aW9uIGJ5IGNhbGxpbmcgYHdzLmNsb3NlKClgLiBUaGlzIGFsbG93cyBhIGNsb3NlIGZyYW1lIHRvIGJlXG4gICAgLy8gICBzZW50IHRvIHRoZSBvdGhlciBwZWVyLiBJZiBgd3MudGVybWluYXRlKClgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGlzLFxuICAgIC8vICAgdGhlbiB0aGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGJlIHNlbnQuXG4gICAgdGVybWluYXRlT25EZXN0cm95ID0gZmFsc2U7XG4gICAgZHVwbGV4LmRlc3Ryb3koZXJyKTtcbiAgfSk7XG5cbiAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgZHVwbGV4LnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIGR1cGxleC5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIWNhbGxlZCkgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRlcm1pbmF0ZU9uRGVzdHJveSkgd3MudGVybWluYXRlKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIGBfc29ja2V0YCBwcm9wZXJ0eSBpcyBgbnVsbGAgaXQgbWVhbnMgdGhhdCBgd3NgIGlzIGFcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcbiAgICAvLyBzb2NrZXQgaXMgbmV2ZXIgYXNzaWduZWQgdG8gdGhlIHdlYnNvY2tldC4gV2FpdCBmb3IgdGhlIGAnZXJyb3InYCBldmVudFxuICAgIC8vIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSB3ZWJzb2NrZXQuXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmICh3cy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSBkdXBsZXguZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgLy8gYGR1cGxleGAgaXMgbm90IGRlc3Ryb3llZCBoZXJlIGJlY2F1c2UgdGhlIGAnZW5kJ2AgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBlbWl0dGVkIG9uIGBkdXBsZXhgIGFmdGVyIHRoaXMgYCdmaW5pc2gnYCBldmVudC4gVGhlIEVPRiBzaWduYWxpbmdcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgd3MuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh3cy5pc1BhdXNlZCkgd3MucmVzdW1lKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3Muc2VuZChjaHVuaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIGR1cGxleC5vbignZW5kJywgZHVwbGV4T25FbmQpO1xuICBkdXBsZXgub24oJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHJldHVybiBkdXBsZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlV2ViU29ja2V0U3RyZWFtO1xuIl0sIm5hbWVzIjpbIkR1cGxleCIsInJlcXVpcmUiLCJlbWl0Q2xvc2UiLCJzdHJlYW0iLCJlbWl0IiwiZHVwbGV4T25FbmQiLCJkZXN0cm95ZWQiLCJfd3JpdGFibGVTdGF0ZSIsImZpbmlzaGVkIiwiZGVzdHJveSIsImR1cGxleE9uRXJyb3IiLCJlcnIiLCJyZW1vdmVMaXN0ZW5lciIsImxpc3RlbmVyQ291bnQiLCJjcmVhdGVXZWJTb2NrZXRTdHJlYW0iLCJ3cyIsIm9wdGlvbnMiLCJ0ZXJtaW5hdGVPbkRlc3Ryb3kiLCJkdXBsZXgiLCJhdXRvRGVzdHJveSIsIm9iamVjdE1vZGUiLCJ3cml0YWJsZU9iamVjdE1vZGUiLCJvbiIsIm1lc3NhZ2UiLCJtc2ciLCJpc0JpbmFyeSIsImRhdGEiLCJfcmVhZGFibGVTdGF0ZSIsInRvU3RyaW5nIiwicHVzaCIsInBhdXNlIiwib25jZSIsImVycm9yIiwiY2xvc2UiLCJfZGVzdHJveSIsImNhbGxiYWNrIiwicmVhZHlTdGF0ZSIsIkNMT1NFRCIsInByb2Nlc3MiLCJuZXh0VGljayIsImNhbGxlZCIsInRlcm1pbmF0ZSIsIl9maW5hbCIsIkNPTk5FQ1RJTkciLCJvcGVuIiwiX3NvY2tldCIsImVuZEVtaXR0ZWQiLCJmaW5pc2giLCJfcmVhZCIsImlzUGF1c2VkIiwicmVzdW1lIiwiX3dyaXRlIiwiY2h1bmsiLCJlbmNvZGluZyIsInNlbmQiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  tokenChars\n} = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (i !== 0 && (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n      if (end === -1) end = i;\n      const protocol = header.slice(start, end);\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n  const protocol = header.slice(start, i);\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n  protocols.add(protocol);\n  return protocols;\n}\nmodule.exports = {\n  parse\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLE1BQU07RUFBRUE7QUFBVyxDQUFDLEdBQUdDLG1CQUFPLENBQUMsK0RBQWMsQ0FBQzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxLQUFLQSxDQUFDQyxNQUFNLEVBQUU7RUFDckIsTUFBTUMsU0FBUyxHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUFDO0VBQzNCLElBQUlDLEtBQUssR0FBRyxDQUFDLENBQUM7RUFDZCxJQUFJQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0VBQ1osSUFBSUMsQ0FBQyxHQUFHLENBQUM7RUFFVCxLQUFLQSxDQUFDLEVBQUVBLENBQUMsR0FBR0wsTUFBTSxDQUFDTSxNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO0lBQzlCLE1BQU1FLElBQUksR0FBR1AsTUFBTSxDQUFDUSxVQUFVLENBQUNILENBQUMsQ0FBQztJQUVqQyxJQUFJRCxHQUFHLEtBQUssQ0FBQyxDQUFDLElBQUlQLFVBQVUsQ0FBQ1UsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO01BQ3hDLElBQUlKLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBRUEsS0FBSyxHQUFHRSxDQUFDO0lBQzdCLENBQUMsTUFBTSxJQUNMQSxDQUFDLEtBQUssQ0FBQyxLQUNORSxJQUFJLEtBQUssSUFBSSxDQUFDLGFBQWFBLElBQUksS0FBSyxJQUFJLENBQUMsQ0FBQyxZQUMzQztNQUNBLElBQUlILEdBQUcsS0FBSyxDQUFDLENBQUMsSUFBSUQsS0FBSyxLQUFLLENBQUMsQ0FBQyxFQUFFQyxHQUFHLEdBQUdDLENBQUM7SUFDekMsQ0FBQyxNQUFNLElBQUlFLElBQUksS0FBSyxJQUFJLENBQUMsV0FBVztNQUNsQyxJQUFJSixLQUFLLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDaEIsTUFBTSxJQUFJTSxXQUFXLENBQUUsaUNBQWdDSixDQUFFLEVBQUMsQ0FBQztNQUM3RDtNQUVBLElBQUlELEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRUEsR0FBRyxHQUFHQyxDQUFDO01BRXZCLE1BQU1LLFFBQVEsR0FBR1YsTUFBTSxDQUFDVyxLQUFLLENBQUNSLEtBQUssRUFBRUMsR0FBRyxDQUFDO01BRXpDLElBQUlILFNBQVMsQ0FBQ1csR0FBRyxDQUFDRixRQUFRLENBQUMsRUFBRTtRQUMzQixNQUFNLElBQUlELFdBQVcsQ0FBRSxRQUFPQyxRQUFTLDZCQUE0QixDQUFDO01BQ3RFO01BRUFULFNBQVMsQ0FBQ1ksR0FBRyxDQUFDSCxRQUFRLENBQUM7TUFDdkJQLEtBQUssR0FBR0MsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNsQixDQUFDLE1BQU07TUFDTCxNQUFNLElBQUlLLFdBQVcsQ0FBRSxpQ0FBZ0NKLENBQUUsRUFBQyxDQUFDO0lBQzdEO0VBQ0Y7RUFFQSxJQUFJRixLQUFLLEtBQUssQ0FBQyxDQUFDLElBQUlDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRTtJQUM5QixNQUFNLElBQUlLLFdBQVcsQ0FBQyx5QkFBeUIsQ0FBQztFQUNsRDtFQUVBLE1BQU1DLFFBQVEsR0FBR1YsTUFBTSxDQUFDVyxLQUFLLENBQUNSLEtBQUssRUFBRUUsQ0FBQyxDQUFDO0VBRXZDLElBQUlKLFNBQVMsQ0FBQ1csR0FBRyxDQUFDRixRQUFRLENBQUMsRUFBRTtJQUMzQixNQUFNLElBQUlELFdBQVcsQ0FBRSxRQUFPQyxRQUFTLDZCQUE0QixDQUFDO0VBQ3RFO0VBRUFULFNBQVMsQ0FBQ1ksR0FBRyxDQUFDSCxRQUFRLENBQUM7RUFDdkIsT0FBT1QsU0FBUztBQUNsQjtBQUVBYSxNQUFNLENBQUNDLE9BQU8sR0FBRztFQUFFaEI7QUFBTSxDQUFDIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy93cy9saWIvc3VicHJvdG9jb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGhlYWRlciBpbnRvIGEgc2V0IG9mIHN1YnByb3RvY29sIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge1NldH0gVGhlIHN1YnByb3RvY29sIG5hbWVzXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGkgIT09IDAgJiZcbiAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuXG4gICAgICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuXG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gIH1cblxuICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgcmV0dXJuIHByb3RvY29scztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHBhcnNlIH07XG4iXSwibmFtZXMiOlsidG9rZW5DaGFycyIsInJlcXVpcmUiLCJwYXJzZSIsImhlYWRlciIsInByb3RvY29scyIsIlNldCIsInN0YXJ0IiwiZW5kIiwiaSIsImxlbmd0aCIsImNvZGUiLCJjaGFyQ29kZUF0IiwiU3ludGF4RXJyb3IiLCJwcm90b2NvbCIsInNsaWNlIiwiaGFzIiwiYWRkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  isUtf8\n} = __webpack_require__(/*! buffer */ \"buffer\");\nconst {\n  hasBlob\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 0 - 15\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 16 - 31\n0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,\n// 32 - 47\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n// 48 - 63\n0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 64 - 79\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n// 80 - 95\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 96 - 111\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||\n      // Overlong\n      buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||\n      // Overlong\n      buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Determines whether a value is a `Blob`.\n *\n * @param {*} value The value to be tested\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n * @private\n */\nfunction isBlob(value) {\n  return hasBlob && typeof value === 'object' && typeof value.arrayBuffer === 'function' && typeof value.type === 'string' && typeof value.stream === 'function' && (value[Symbol.toStringTag] === 'Blob' || value[Symbol.toStringTag] === 'File');\n}\nmodule.exports = {\n  isBlob,\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\nif (isUtf8) {\n  module.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} /* istanbul ignore else  */else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"?66e9\");\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsTUFBTTtFQUFFQTtBQUFPLENBQUMsR0FBR0MsbUJBQU8sQ0FBQyxzQkFBUSxDQUFDO0FBRXBDLE1BQU07RUFBRUM7QUFBUSxDQUFDLEdBQUdELG1CQUFPLENBQUMsNkRBQWEsQ0FBQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUUsVUFBVSxHQUFHLENBQ2pCLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFBRTtBQUNoRCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0FBQUU7QUFDaEQsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUFFO0FBQ2hELENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFBRTtBQUNoRCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0FBQUU7QUFDaEQsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUFFO0FBQ2hELENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFBRTtBQUNoRCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFBQSxDQUNoRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLGlCQUFpQkEsQ0FBQ0MsSUFBSSxFQUFFO0VBQy9CLE9BQ0dBLElBQUksSUFBSSxJQUFJLElBQ1hBLElBQUksSUFBSSxJQUFJLElBQ1pBLElBQUksS0FBSyxJQUFJLElBQ2JBLElBQUksS0FBSyxJQUFJLElBQ2JBLElBQUksS0FBSyxJQUFJLElBQ2RB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b24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGlzVXRmOCB9ID0gcmVxdWlyZSgnYnVmZmVyJyk7XG5cbmNvbnN0IHsgaGFzQmxvYiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuLy9cbi8vIEFsbG93ZWQgdG9rZW4gY2hhcmFjdGVyczpcbi8vXG4vLyAnIScsICcjJywgJyQnLCAnJScsICcmJywgJycnLCAnKicsICcrJywgJy0nLFxuLy8gJy4nLCAwLTksIEEtWiwgJ14nLCAnXycsICdgJywgYS16LCAnfCcsICd+J1xuLy9cbi8vIHRva2VuQ2hhcnNbMzJdID09PSAwIC8vICcgJ1xuLy8gdG9rZW5DaGFyc1szM10gPT09IDEgLy8gJyEnXG4vLyB0b2tlbkNoYXJzWzM0XSA9PT0gMCAvLyAnXCInXG4vLyAuLi5cbi8vXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHRva2VuQ2hhcnMgPSBbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDAgLSAxNVxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXG4gIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDAsIC8vIDMyIC0gNDdcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gNDggLSA2M1xuICAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDEsIC8vIDgwIC0gOTVcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gOTYgLSAxMTFcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcbl07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhdHVzIGNvZGUgaXMgYWxsb3dlZCBpbiBhIGNsb3NlIGZyYW1lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBzdGF0dXMgY29kZSBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICAoY29kZSA+PSAxMDAwICYmXG4gICAgICBjb2RlIDw9IDEwMTQgJiZcbiAgICAgIGNvZGUgIT09IDEwMDQgJiZcbiAgICAgIGNvZGUgIT09IDEwMDUgJiZcbiAgICAgIGNvZGUgIT09IDEwMDYpIHx8XG4gICAgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpXG4gICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYnVmZmVyIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOC5cbiAqIFBvcnRlZCBmcm9tIGh0dHBzOi8vd3d3LmNsLmNhbS5hYy51ay8lN0VtZ2syNS91Y3MvdXRmOF9jaGVjay5jIGJ5XG4gKiBNYXJrdXMgS3Vobi5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgYnVmYCBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTgsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfaXNWYWxpZFVURjgoYnVmKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gIGxldCBpID0gMDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmICgoYnVmW2ldICYgMHg4MCkgPT09IDApIHtcbiAgICAgIC8vIDB4eHh4eHh4XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgIC8vIDExMHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAxID09PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldICYgMHhmZSkgPT09IDB4YzAgLy8gT3ZlcmxvbmdcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMjtcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgLy8gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDIgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldID09PSAweGUwICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXG4gICAgICAgIChidWZbaV0gPT09IDB4ZWQgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHhhMCkgLy8gU3Vycm9nYXRlIChVK0Q4MDAgLSBVK0RGRkYpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDM7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgIC8vIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAzID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgM10gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldID09PSAweGYwICYmIChidWZbaSArIDFdICYgMHhmMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXG4gICAgICAgIChidWZbaV0gPT09IDB4ZjQgJiYgYnVmW2kgKyAxXSA+IDB4OGYpIHx8XG4gICAgICAgIGJ1ZltpXSA+IDB4ZjQgLy8gPiBVKzEwRkZGRlxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgdmFsdWUgaXMgYSBgQmxvYmAuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGBCbG9iYCwgZWxzZSBgZmFsc2VgXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBoYXNCbG9iICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5zdHJlYW0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAodmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0Jsb2InIHx8XG4gICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnRmlsZScpXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0Jsb2IsXG4gIGlzVmFsaWRTdGF0dXNDb2RlLFxuICBpc1ZhbGlkVVRGODogX2lzVmFsaWRVVEY4LFxuICB0b2tlbkNoYXJzXG59O1xuXG5pZiAoaXNVdGY4KSB7XG4gIG1vZHVsZS5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHJldHVybiBidWYubGVuZ3RoIDwgMjQgPyBfaXNWYWxpZFVURjgoYnVmKSA6IGlzVXRmOChidWYpO1xuICB9O1xufSAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi8gZWxzZSBpZiAoIXByb2Nlc3MuZW52LldTX05PX1VURl84X1ZBTElEQVRFKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgaXNWYWxpZFVURjggPSByZXF1aXJlKCd1dGYtOC12YWxpZGF0ZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMuaXNWYWxpZFVURjggPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDMyID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1ZhbGlkVVRGOChidWYpO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBDb250aW51ZSByZWdhcmRsZXNzIG9mIHRoZSBlcnJvci5cbiAgfVxufVxuIl0sIm5hbWVzIjpbImlzVXRmOCIsInJlcXVpcmUiLCJoYXNCbG9iIiwidG9rZW5DaGFycyIsImlzVmFsaWRTdGF0dXNDb2RlIiwiY29kZSIsIl9pc1ZhbGlkVVRGOCIsImJ1ZiIsImxlbiIsImxlbmd0aCIsImkiLCJpc0Jsb2IiLCJ2YWx1ZSIsImFycmF5QnVmZmVyIiwidHlwZSIsInN0cmVhbSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwibW9kdWxlIiwiZXhwb3J0cyIsImlzVmFsaWRVVEY4IiwicHJvY2VzcyIsImVudiIsIldTX05PX1VURl84X1ZBTElEQVRFIiwiZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst {\n  Duplex\n} = __webpack_require__(/*! stream */ \"stream\");\nconst {\n  createHash\n} = __webpack_require__(/*! crypto */ \"crypto\");\nconst extension = __webpack_require__(/*! ./extension */ \"(rsc)/./node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"(rsc)/./node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/ws/lib/websocket.js\");\nconst {\n  GUID,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n    options = {\n      allowSynchronousEvents: true,\n      autoPong: true,\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n      throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + 'must be specified');\n    }\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n      process.nextTick(emitClose, this);\n      return;\n    }\n    if (cb) this.once('close', cb);\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n      if (pathname !== this.options.path) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n    const key = req.headers['sec-websocket-key'];\n    const upgrade = req.headers.upgrade;\n    const version = +req.headers['sec-websocket-version'];\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (key === undefined || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n    if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {\n      const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message = 'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n          this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n        });\n        return;\n      }\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n    if (socket[kWebSocket]) {\n      throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');\n    }\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n    const headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', `Sec-WebSocket-Accept: ${digest}`];\n    const ws = new this.options.WebSocket(null, undefined, this.options);\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n    ws.setSocket(socket, head, {\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n    cb(ws, req);\n  }\n}\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n  socket.once('finish', socket.destroy);\n  socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map(h => `${h}: ${headers[h]}`).join('\\r\\n') + '\\r\\n\\r\\n' + message);\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRWE7O0FBRWIsTUFBTUEsWUFBWSxHQUFHQyxtQkFBTyxDQUFDLHNCQUFRLENBQUM7QUFDdEMsTUFBTUMsSUFBSSxHQUFHRCxtQkFBTyxDQUFDLGtCQUFNLENBQUM7QUFDNUIsTUFBTTtFQUFFRTtBQUFPLENBQUMsR0FBR0YsbUJBQU8sQ0FBQyxzQkFBUSxDQUFDO0FBQ3BDLE1BQU07RUFBRUc7QUFBVyxDQUFDLEdBQUdILG1CQUFPLENBQUMsc0JBQVEsQ0FBQztBQUV4QyxNQUFNSSxTQUFTLEdBQUdKLG1CQUFPLENBQUMsNkRBQWEsQ0FBQztBQUN4QyxNQUFNSyxpQkFBaUIsR0FBR0wsbUJBQU8sQ0FBQywrRUFBc0IsQ0FBQztBQUN6RCxNQUFNTSxXQUFXLEdBQUdOLG1CQUFPLENBQUMsaUVBQWUsQ0FBQztBQUM1QyxNQUFNTyxTQUFTLEdBQUdQLG1CQUFPLENBQUMsNkRBQWEsQ0FBQztBQUN4QyxNQUFNO0VBQUVRLElBQUk7RUFBRUM7QUFBVyxDQUFDLEdBQUdULG1CQUFPLENBQUMsNkRBQWEsQ0FBQztBQUVuRCxNQUFNVSxRQUFRLEdBQUcsdUJBQXVCO0FBRXhDLE1BQU1DLE9BQU8sR0FBRyxDQUFDO0FBQ2pCLE1BQU1DLE9BQU8sR0FBRyxDQUFDO0FBQ2pCLE1BQU1DLE1BQU0sR0FBRyxDQUFDOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsZUFBZSxTQUFTZixZQUFZLENBQUM7RUFDekM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRWdCLFdBQVdBLENBQUNDLE9BQU8sRUFBRUMsUUFB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UixpQ0FBaUMsQ0FBQztJQUUvRHBELE1BQU0sQ0FBQ2dCLElBQUksQ0FBQyxlQUFlLEVBQUU0QyxHQUFHLEVBQUVyQyxNQUFNLEVBQUVoQixHQUFHLENBQUM7RUFDaEQsQ0FBQyxNQUFNO0lBQ0xpRCxjQUFjLENBQUNqQyxNQUFNLEVBQUVpRCxJQUFJLEVBQUVyQixPQUFPLENBQUM7RUFDdkM7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4JFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IGV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBzdWJwcm90b2NvbCA9IHJlcXVpcmUoJy4vc3VicHJvdG9jb2wnKTtcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5jb25zdCB7IEdVSUQsIGtXZWJTb2NrZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGtleVJlZ2V4ID0gL15bKy8wLTlBLVphLXpdezIyfT09JC87XG5cbmNvbnN0IFJVTk5JTkcgPSAwO1xuY29uc3QgQ0xPU0lORyA9IDE7XG5jb25zdCBDTE9TRUQgPSAyO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvUG9uZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIGF1dG9tYXRpY2FsbHkgc2VuZCBhIHBvbmcgaW4gcmVzcG9uc2UgdG8gYSBwaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYWNrbG9nPTUxMV0gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBxdWV1ZSBvZlxuICAgKiAgICAgcGVuZGluZyBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudFRyYWNraW5nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgdHJhY2sgY2xpZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oYW5kbGVQcm90b2NvbHNdIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ob3N0XSBUaGUgaG9zdG5hbWUgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gICAqICAgICBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9TZXJ2ZXI9ZmFsc2VdIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aF0gQWNjZXB0IG9ubHkgY29ubmVjdGlvbnMgbWF0Y2hpbmcgdGhpcyBwYXRoXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9ZmFsc2VdIEVuYWJsZS9kaXNhYmxlXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvcnRdIFRoZSBwb3J0IHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0geyhodHRwLlNlcnZlcnxodHRwcy5TZXJ2ZXIpfSBbb3B0aW9ucy5zZXJ2ZXJdIEEgcHJlLWNyZWF0ZWQgSFRUUC9TXG4gICAqICAgICBzZXJ2ZXIgdG8gdXNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLldlYlNvY2tldD1XZWJTb2NrZXRdIFNwZWNpZmllcyB0aGUgYFdlYlNvY2tldGBcbiAgICogICAgIGNsYXNzIHRvIHVzZS4gSXQgbXVzdCBiZSB0aGUgYFdlYlNvY2tldGAgY2xhc3Mgb3IgY2xhc3MgdGhhdCBleHRlbmRzIGl0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdHJ1ZSxcbiAgICAgIGF1dG9Qb25nOiB0cnVlLFxuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIFdlYlNvY2tldCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKFxuICAgICAgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikgfHxcbiAgICAgIChvcHRpb25zLnBvcnQgIT0gbnVsbCAmJiAob3B0aW9ucy5zZXJ2ZXIgfHwgb3B0aW9ucy5ub1NlcnZlcikpIHx8XG4gICAgICAob3B0aW9ucy5zZXJ2ZXIgJiYgb3B0aW9ucy5ub1NlcnZlcilcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdPbmUgYW5kIG9ubHkgb25lIG9mIHRoZSBcInBvcnRcIiwgXCJzZXJ2ZXJcIiwgb3IgXCJub1NlcnZlclwiIG9wdGlvbnMgJyArXG4gICAgICAgICAgJ211c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gaHR0cC5TVEFUVVNfQ09ERVNbNDI2XTtcblxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xuICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5lbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4oXG4gICAgICAgIG9wdGlvbnMucG9ydCxcbiAgICAgICAgb3B0aW9ucy5ob3N0LFxuICAgICAgICBvcHRpb25zLmJhY2tsb2csXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nvbm5lY3Rpb24nKTtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPT09IHRydWUpIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykge1xuICAgICAgdGhpcy5jbGllbnRzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBzZXJ2ZXIgZnJvbSBhY2NlcHRpbmcgbmV3IGNvbm5lY3Rpb25zIGFuZCBlbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogd2hlbiBhbGwgZXhpc3RpbmcgY29ubmVjdGlvbnMgYXJlIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBBIG9uZS10aW1lIGxpc3RlbmVyIGZvciB0aGUgYCdjbG9zZSdgIGV2ZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIGNiKG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBub3QgcnVubmluZycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NJTkc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuc2l6ZSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX3NlcnZlcjtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIEhUVFAvUyBzZXJ2ZXIgd2FzIGNyZWF0ZWQgaW50ZXJuYWxseS4gQ2xvc2UgaXQsIGFuZCByZWx5IG9uIGl0c1xuICAgICAgLy8gYCdjbG9zZSdgIGV2ZW50LlxuICAgICAgLy9cbiAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgIGVtaXRDbG9zZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUgaWYgYSBnaXZlbiByZXF1ZXN0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoaXMgc2VydmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgUmVxdWVzdCBvYmplY3QgdG8gaW5zcGVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzaG91bGRIYW5kbGUocmVxKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHJlcS51cmwuaW5kZXhPZignPycpO1xuICAgICAgY29uc3QgcGF0aG5hbWUgPSBpbmRleCAhPT0gLTEgPyByZXEudXJsLnNsaWNlKDAsIGluZGV4KSA6IHJlcS51cmw7XG5cbiAgICAgIGlmIChwYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICBjb25zdCBrZXkgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXTtcbiAgICBjb25zdCB1cGdyYWRlID0gcmVxLmhlYWRlcnMudXBncmFkZTtcbiAgICBjb25zdCB2ZXJzaW9uID0gK3JlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXTtcblxuICAgIGlmIChyZXEubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIEhUVFAgbWV0aG9kJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDA1LCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSA9PT0gdW5kZWZpbmVkIHx8IHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8ICFrZXlSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtS2V5IGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gIT09IDggJiYgdmVyc2lvbiAhPT0gMTMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtVmVyc2lvbiBoZWFkZXInO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zaG91bGRIYW5kbGUocmVxKSkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldFByb3RvY29sID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICBsZXQgcHJvdG9jb2xzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldFByb3RvY29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByb3RvY29scyA9IHN1YnByb3RvY29sLnBhcnNlKHNlY1dlYlNvY2tldFByb3RvY29sKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgICAgICBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnSW52YWxpZCBvciB1bmFjY2VwdGFibGUgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIGNsaWVudCB2ZXJpZmljYXRpb24gaGFuZGxlci5cbiAgICAvL1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBvcmlnaW46XG4gICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcbiAgICAgICAgc2VjdXJlOiAhIShyZXEuc29ja2V0LmF1dGhvcml6ZWQgfHwgcmVxLnNvY2tldC5lbmNyeXB0ZWQpLFxuICAgICAgICByZXFcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8sICh2ZXJpZmllZCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykgPT4ge1xuICAgICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUgfHwgNDAxLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgY2JcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZSB0aGUgY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIHZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1LZXlgIGhlYWRlclxuICAgKiBAcGFyYW0ge1NldH0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICAvL1xuICAgIC8vIERlc3Ryb3kgdGhlIHNvY2tldCBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IHNlbnQgYSBGSU4gcGFja2V0LlxuICAgIC8vXG4gICAgaWYgKCFzb2NrZXQucmVhZGFibGUgfHwgIXNvY2tldC53cml0YWJsZSkgcmV0dXJuIHNvY2tldC5kZXN0cm95KCk7XG5cbiAgICBpZiAoc29ja2V0W2tXZWJTb2NrZXRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcbiAgICAgICAgICAnc29ja2V0LCBwb3NzaWJseSBkdWUgdG8gYSBtaXNjb25maWd1cmF0aW9uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPiBSVU5OSU5HKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA1MDMpO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgICAgJ1VwZ3JhZGU6IHdlYnNvY2tldCcsXG4gICAgICAnQ29ubmVjdGlvbjogVXBncmFkZScsXG4gICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcbiAgICBdO1xuXG4gICAgY29uc3Qgd3MgPSBuZXcgdGhpcy5vcHRpb25zLldlYlNvY2tldChudWxsLCB1bmRlZmluZWQsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBpZiAocHJvdG9jb2xzLnNpemUpIHtcbiAgICAgIC8vXG4gICAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgcHJvdG9jb2wgc2VsZWN0aW9uIGhhbmRsZXIuXG4gICAgICAvL1xuICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXG4gICAgICAgID8gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scyhwcm90b2NvbHMsIHJlcSlcbiAgICAgICAgOiBwcm90b2NvbHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LVByb3RvY29sOiAke3Byb3RvY29sfWApO1xuICAgICAgICB3cy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5wYXJhbXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5mb3JtYXQoe1xuICAgICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IFtwYXJhbXNdXG4gICAgICB9KTtcbiAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zOiAke3ZhbHVlfWApO1xuICAgICAgd3MuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQWxsb3cgZXh0ZXJuYWwgbW9kaWZpY2F0aW9uL2luc3BlY3Rpb24gb2YgaGFuZHNoYWtlIGhlYWRlcnMuXG4gICAgLy9cbiAgICB0aGlzLmVtaXQoJ2hlYWRlcnMnLCBoZWFkZXJzLCByZXEpO1xuXG4gICAgc29ja2V0LndyaXRlKGhlYWRlcnMuY29uY2F0KCdcXHJcXG4nKS5qb2luKCdcXHJcXG4nKSk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgd3Muc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdGhpcy5vcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMsXG4gICAgICBtYXhQYXlsb2FkOiB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogdGhpcy5vcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgdGhpcy5jbGllbnRzLmFkZCh3cyk7XG4gICAgICB3cy5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUod3MpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRFbWl0Q2xvc2UgJiYgIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYih3cywgcmVxKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XG4gKiBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWRkZWQgbGlzdGVuZXJzIHdoZW5cbiAqICAgICBjYWxsZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhzZXJ2ZXIsIG1hcCkge1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHNlcnZlci5vbihldmVudCwgbWFwW2V2ZW50XSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcbiAgICAgIHNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbWFwW2V2ZW50XSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEVtaXQgYSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYW4gYEV2ZW50RW1pdHRlcmAuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHNlcnZlcikge1xuICBzZXJ2ZXIuX3N0YXRlID0gQ0xPU0VEO1xuICBzZXJ2ZXIuZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgc29ja2V0IGVycm9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXG4gKlxuICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICAvL1xuICAvLyBUaGUgc29ja2V0IGlzIHdyaXRhYmxlIHVubGVzcyB0aGUgdXNlciBkZXN0cm95ZWQgb3IgZW5kZWQgaXQgYmVmb3JlIGNhbGxpbmdcbiAgLy8gYHNlcnZlci5oYW5kbGVVcGdyYWRlKClgIG9yIGluIHRoZSBgdmVyaWZ5Q2xpZW50YCBmdW5jdGlvbiwgd2hpY2ggaXMgYSB1c2VyXG4gIC8vIGVycm9yLiBIYW5kbGluZyB0aGlzIGRvZXMgbm90IG1ha2UgbXVjaCBzZW5zZSBhcyB0aGUgd29yc3QgdGhhdCBjYW4gaGFwcGVuXG4gIC8vIGlzIHRoYXQgc29tZSBvZiB0aGUgZGF0YSB3cml0dGVuIGJ5IHRoZSB1c2VyIG1pZ2h0IGJlIGRpc2NhcmRlZCBkdWUgdG8gdGhlXG4gIC8vIGNhbGwgdG8gYHNvY2tldC5lbmQoKWAgYmVsb3csIHdoaWNoIHRyaWdnZXJzIGFuIGAnZXJyb3InYCBldmVudCB0aGF0IGluXG4gIC8vIHR1cm4gY2F1c2VzIHRoZSBzb2NrZXQgdG8gYmUgZGVzdHJveWVkLlxuICAvL1xuICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcbiAgaGVhZGVycyA9IHtcbiAgICBDb25uZWN0aW9uOiAnY2xvc2UnLFxuICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcbiAgICAnQ29udGVudC1MZW5ndGgnOiBCdWZmZXIuYnl0ZUxlbmd0aChtZXNzYWdlKSxcbiAgICAuLi5oZWFkZXJzXG4gIH07XG5cbiAgc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIHNvY2tldC5kZXN0cm95KTtcblxuICBzb2NrZXQuZW5kKFxuICAgIGBIVFRQLzEuMSAke2NvZGV9ICR7aHR0cC5TVEFUVVNfQ09ERVNbY29kZV19XFxyXFxuYCArXG4gICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApXG4gICAgICAgIC5qb2luKCdcXHJcXG4nKSArXG4gICAgICAnXFxyXFxuXFxyXFxuJyArXG4gICAgICBtZXNzYWdlXG4gICk7XG59XG5cbi8qKlxuICogRW1pdCBhIGAnd3NDbGllbnRFcnJvcidgIGV2ZW50IG9uIGEgYFdlYlNvY2tldFNlcnZlcmAgaWYgdGhlcmUgaXMgYXQgbGVhc3RcbiAqIG9uZSBsaXN0ZW5lciBmb3IgaXQsIG90aGVyd2lzZSBjYWxsIGBhYm9ydEhhbmRzaGFrZSgpYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldFNlcnZlcn0gc2VydmVyIFRoZSBXZWJTb2NrZXQgc2VydmVyXG4gKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcihzZXJ2ZXIsIHJlcSwgc29ja2V0LCBjb2RlLCBtZXNzYWdlKSB7XG4gIGlmIChzZXJ2ZXIubGlzdGVuZXJDb3VudCgnd3NDbGllbnRFcnJvcicpKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKTtcblxuICAgIHNlcnZlci5lbWl0KCd3c0NsaWVudEVycm9yJywgZXJyLCBzb2NrZXQsIHJlcSk7XG4gIH0gZWxzZSB7XG4gICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsInJlcXVpcmUiLCJodHRwIiwiRHVwbGV4IiwiY3JlYXRlSGFzaCIsImV4dGVuc2lvbiIsIlBlck1lc3NhZ2VEZWZsYXRlIiwic3VicHJvdG9jb2wiLCJXZWJTb2NrZXQiLCJHVUlEIiwia1dlYlNvY2tldCIsImtleVJlZ2V4IiwiUlVOTklORyIsIkNMT1NJTkciLCJDTE9TRUQiLCJXZWJTb2NrZXRTZXJ2ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImFsbG93U3luY2hyb25vdXNFdmVudHMiLCJhdXRvUG9uZyIsIm1heFBheWxvYWQiLCJza2lwVVRGOFZhbGlkYXRpb24iLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImhhbmRsZVByb3RvY29scyIsImNsaWVudFRyYWNraW5nIiwidmVyaWZ5Q2xpZW50Iiwibm9TZXJ2ZXIiLCJiYWNrbG9nIiwic2VydmVyIiwiaG9zdCIsInBhdGgiLCJwb3J0IiwiVHlwZUVycm9yIiwiX3NlcnZlciIsImNyZWF0ZVNlcnZlciIsInJlcSIsInJlcyIsImJvZHkiLCJTVEFUVVNfQ09ERVMiLCJ3cml0ZUhlYWQiLCJsZW5ndGgiLCJlbmQiLCJsaXN0ZW4iLCJlbWl0Q29ubmVjdGlvbiIsImVtaXQiLCJiaW5kIiwiX3JlbW92ZUxpc3RlbmVycyIsImFkZExpc3RlbmVycyIsImxpc3RlbmluZyIsImVycm9yIiwidXBncmFkZSIsInNvY2tldCIsImhlYWQiLCJoYW5kbGVVcGdyYWRlIiwiY2xpZW50cyIsIlNldCIsIl9zaG91bGRFbWl0Q2xvc2UiLCJfc3RhdGUiLCJhZGRyZXNzIiwiRXJyb3IiLCJjbG9zZSIsImNiIiwib25jZSIsInByb2Nlc3MiLCJuZXh0VGljayIsImVtaXRDbG9zZSIsInNpemUiLCJzaG91bGRIYW5kbGUiLCJpbmRleCIsInVybCIsImluZGV4T2YiLCJwYXRobmFtZSIsInNsaWNlIiwib24iLCJzb2NrZXRPbkVycm9yIiwia2V5IiwiaGVhZGVycyIsInZlcnNpb24iLCJtZXRob2QiLCJtZXNzYWdlIiwiYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yIiwidW5kZWZpbmVkIiwidG9Mb3dlckNhc2UiLCJ0ZXN0IiwiYWJvcnRIYW5kc2hha2UiLCJzZWNXZWJTb2NrZXRQcm90b2NvbCIsInByb3RvY29scyIsInBhcnNlIiwiZXJyIiwic2VjV2ViU29ja2V0RXh0ZW5zaW9ucyIsImV4dGVuc2lvbnMiLCJvZmZlcnMiLCJleHRlbnNpb25OYW1lIiwiYWNjZXB0IiwiaW5mbyIsIm9yaWdpbiIsInNlY3VyZSIsImF1dGhvcml6ZWQiLCJlbmNyeXB0ZWQiLCJ2ZXJpZmllZCIsImNvZGUiLCJjb21wbGV0ZVVwZ3JhZGUiLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwiZGVzdHJveSIsImRpZ2VzdCIsInVwZGF0ZSIsIndzIiwicHJvdG9jb2wiLCJ2YWx1ZXMiLCJuZXh0IiwidmFsdWUiLCJwdXNoIiwiX3Byb3RvY29sIiwicGFyYW1zIiwiZm9ybWF0IiwiX2V4dGVuc2lvbnMiLCJ3cml0ZSIsImNvbmNhdCIsImpvaW4iLCJyZW1vdmVMaXN0ZW5lciIsInNldFNvY2tldCIsImFkZCIsImRlbGV0ZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJtYXAiLCJldmVudCIsIk9iamVjdCIsImtleXMiLCJyZW1vdmVMaXN0ZW5lcnMiLCJDb25uZWN0aW9uIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsImgiLCJsaXN0ZW5lckNvdW50IiwiY2FwdHVyZVN0YWNrVHJhY2UiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst {\n  randomBytes,\n  createHash\n} = __webpack_require__(/*! crypto */ \"crypto\");\nconst {\n  Duplex,\n  Readable\n} = __webpack_require__(/*! stream */ \"stream\");\nconst {\n  URL\n} = __webpack_require__(/*! url */ \"url\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(rsc)/./node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"(rsc)/./node_modules/ws/lib/sender.js\");\nconst {\n  isBlob\n} = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst {\n  EventTarget: {\n    addEventListener,\n    removeEventListener\n  }\n} = __webpack_require__(/*! ./event-target */ \"(rsc)/./node_modules/ws/lib/event-target.js\");\nconst {\n  format,\n  parse\n} = __webpack_require__(/*! ./extension */ \"(rsc)/./node_modules/ws/lib/extension.js\");\nconst {\n  toBuffer\n} = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ws/lib/buffer-util.js\");\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._errorEmitted = false;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._autoPong = options.autoPong;\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n   * instead of \"blob\".\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      allowSynchronousEvents: options.allowSynchronousEvents,\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n    const sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._sender = sender;\n    this._socket = socket;\n    receiver[kWebSocket] = this;\n    sender[kWebSocket] = this;\n    socket[kWebSocket] = this;\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n    sender.onerror = senderOnError;\n\n    //\n    // These methods may not be available if `socket` is just a `Duplex`.\n    //\n    if (socket.setTimeout) socket.setTimeout(0);\n    if (socket.setNoDelay) socket.setNoDelay();\n    if (head.length > 0) socket.unshift(head);\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n        this._socket.end();\n      }\n      return;\n    }\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, err => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n        this._socket.end();\n      }\n    });\n    setCloseTimer(this);\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n['binaryType', 'bufferedAmount', 'extensions', 'isPaused', 'protocol', 'readyState', 'url'].forEach(property => {\n  Object.defineProperty(WebSocket.prototype, property, {\n    enumerable: true\n  });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach(method => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n      if (typeof handler !== 'function') return;\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    allowSynchronousEvents: true,\n    autoPong: true,\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n  websocket._autoPong = opts.autoPong;\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);\n  }\n  let parsedUrl;\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n  websocket._url = parsedUrl.href;\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  let invalidUrlMessage;\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage = 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' + '\"http:\", \"https\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n  opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n        throw new SyntaxError('An invalid or duplicated subprotocol was specified');\n      }\n      protocolSet.add(protocol);\n    }\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n  if (isIpcUrl) {\n    const parts = opts.path.split(':');\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n  let req;\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = {\n        ...options,\n        headers: {}\n      };\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n      if (!isSameHost || websocket._originalSecure && !isSecure) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n        if (!isSameHost) delete opts.headers.host;\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n    req = websocket._req = request(opts);\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n  req.on('error', err => {\n    if (req === null || req[kAborted]) return;\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n  req.on('response', res => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n      req.abort();\n      let addr;\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n    }\n  });\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n    req = websocket._req = null;\n    const upgrade = res.headers.upgrade;\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n    if (serverProt) websocket._protocol = serverProt;\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      let extensions;\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      const extensionNames = Object.keys(extensions);\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n    }\n    websocket.setSocket(socket, head, {\n      allowSynchronousEvents: opts.allowSynchronousEvents,\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  //\n  // The following assignment is practically useless and is done only for\n  // consistency.\n  //\n  websocket._errorEmitted = true;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;\n  }\n  if (cb) {\n    const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n    process.nextTick(cb, err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n  if (websocket._socket[kWebSocket] === undefined) return;\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n  if (code === 1005) websocket.close();else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n    websocket.close(err[kStatusCode]);\n  }\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The `Sender` error event handler.\n *\n * @param {Error} The error\n * @private\n */\nfunction senderOnError(err) {\n  const websocket = this[kWebSocket];\n  if (websocket.readyState === WebSocket.CLOSED) return;\n  if (websocket.readyState === WebSocket.OPEN) {\n    websocket._readyState = WebSocket.CLOSING;\n    setCloseTimer(websocket);\n  }\n\n  //\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\n  // peer to finish sending queued data. There is no need to set a timer here\n  // because `CLOSING` means that it is already set or not needed.\n  //\n  this._socket.end();\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * Set a timer to destroy the underlying raw socket of a WebSocket.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @private\n */\nfunction setCloseTimer(websocket) {\n  websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);\n}\n\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n  websocket._readyState = WebSocket.CLOSING;\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n    websocket._receiver.write(chunk);\n  }\n  websocket._receiver.end();\n  this[kWebSocket] = undefined;\n  clearTimeout(websocket._closeTimer);\n  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFYTs7QUFFYixNQUFNQSxZQUFZLEdBQUdDLG1CQUFPLENBQUMsc0JBQVEsQ0FBQztBQUN0QyxNQUFNQyxLQUFLLEdBQUdELG1CQUFPLENBQUMsb0JBQU8sQ0FBQztBQUM5QixNQUFNRSxJQUFJLEdBQUdGLG1CQUFPLENBQUMsa0JBQU0sQ0FBQztBQUM1QixNQUFNRyxHQUFHLEdBQUdILG1CQUFPLENBQUMsZ0JBQUssQ0FBQztBQUMxQixNQUFNSSxHQUFHLEdBQUdKLG1CQUFPLENBQUMsZ0JBQUssQ0FBQztBQUMxQixNQUFNO0VBQUVLLFdBQVc7RUFBRUM7QUFBVyxDQUFDLEdBQUdOLG1CQUFPLENBQUMsc0JBQVEsQ0FBQztBQUNyRCxNQUFNO0VBQUVPLE1BQU07RUFBRUM7QUFBUyxDQUFDLEdBQUdSLG1CQUFPLENBQUMsc0JBQVEsQ0FBQztBQUM5QyxNQUFNO0VBQUVTO0FBQUksQ0FBQyxHQUFHVCxtQkFBTyxDQUFDLGdCQUFLLENBQUM7QUFFOUIsTUFBTVUsaUJBQWlCLEdBQUdWLG1CQUFPLENBQUMsK0VBQXNCLENBQUM7QUFDekQsTUFBTVcsUUFBUSxHQUFHWCxtQkFBTyxDQUFDLDJEQUFZLENBQUM7QUFDdEMsTUFBTVksTUFBTSxHQUFHWixtQkFBTyxDQUFDLHVEQUFVLENBQUM7QUFDbEMsTUFBTTtFQUFFYTtBQUFPLENBQUMsR0FBR2IsbUJBQU8sQ0FBQywrREFBYyxDQUFDO0FBRTFDLE1BQU07RUFDSmMsWUFBWTtFQUNaQyxZQUFZO0VBQ1pDLElBQUk7RUFDSkMsb0JBQW9CO0VBQ3BCQyxTQUFTO0VBQ1RDLFdBQVc7RUFDWEMsVUFBVTtFQUNWQztBQUNGLENBQUMsR0FBR3JCLG1CQUFPLENBQUMsNkRBQWEsQ0FBQztBQUMxQixNQUFNO0VBQ0pzQixXQUFXLEVBQUU7SUFBRUMsZ0JBQWdCO0lBQUVDO0VBQW9CO0FBQ3ZELENBQUMsR0FBR3hCLG1C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VSxDQUFDO0VBRWxDLElBQUksQ0FBQ3dJLGNBQWMsQ0FBQyxPQUFPLEVBQUVqRCxhQUFhLENBQUM7RUFDM0MsSUFBSSxDQUFDZCxFQUFFLENBQUMsT0FBTyxFQUFFeEUsSUFBSSxDQUFDO0VBRXRCLElBQUkwSSxTQUFTLEVBQUU7SUFDYkEsU0FBUyxDQUFDOUcsV0FBVyxHQUFHZixTQUFTLENBQUN1RixPQUFPO0lBQ3pDLElBQUksQ0FBQ3FCLE9BQU8sQ0FBQyxDQUFDO0VBQ2hCO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4fFJlYWRhYmxlJFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XG5jb25zdCB7IHJhbmRvbUJ5dGVzLCBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IHsgRHVwbGV4LCBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpO1xuY29uc3QgU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXInKTtcbmNvbnN0IHsgaXNCbG9iIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAgR1VJRCxcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGUsXG4gIGtMaXN0ZW5lcixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXQsXG4gIE5PT1Bcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3Qge1xuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cbn0gPSByZXF1aXJlKCcuL2V2ZW50LXRhcmdldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5jb25zdCBrQWJvcnRlZCA9IFN5bWJvbCgna0Fib3J0ZWQnKTtcbmNvbnN0IHByb3RvY29sVmVyc2lvbnMgPSBbOCwgMTNdO1xuY29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuY29uc3Qgc3VicHJvdG9jb2xSZWdleCA9IC9eWyEjJCUmJyorXFwtLjAtOUEtWl5fYHxhLXp+XSskLztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gRU1QVFlfQlVGRkVSO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2Vycm9yRW1pdHRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm90b2NvbCA9ICcnO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuXG4gICAgICBpZiAocHJvdG9jb2xzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm90b2NvbHMgPT09ICdvYmplY3QnICYmIHByb3RvY29scyAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2F1dG9Qb25nID0gb3B0aW9ucy5hdXRvUG9uZztcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yIGhpc3RvcmljYWwgcmVhc29ucywgdGhlIGN1c3RvbSBcIm5vZGVidWZmZXJcIiB0eXBlIGlzIHVzZWQgYnkgdGhlIGRlZmF1bHRcbiAgICogaW5zdGVhZCBvZiBcImJsb2JcIi5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBiaW5hcnlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xuICAgIGlmICghQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSByZXR1cm47XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxuICAgIC8vXG4gICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xuXG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5sZW5ndGggKyB0aGlzLl9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBleHRlbnNpb25zKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9leHRlbnNpb25zKS5qb2luKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNQYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25jbG9zZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25lcnJvcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25vcGVuKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBwcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByZWFkeVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHRoZSBzb2NrZXQgYW5kIHRoZSBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKHtcbiAgICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIGJpbmFyeVR5cGU6IHRoaXMuYmluYXJ5VHlwZSxcbiAgICAgIGV4dGVuc2lvbnM6IHRoaXMuX2V4dGVuc2lvbnMsXG4gICAgICBpc1NlcnZlcjogdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBtYXhQYXlsb2FkOiBvcHRpb25zLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBjb25zdCBzZW5kZXIgPSBuZXcgU2VuZGVyKHNvY2tldCwgdGhpcy5fZXh0ZW5zaW9ucywgb3B0aW9ucy5nZW5lcmF0ZU1hc2spO1xuXG4gICAgdGhpcy5fcmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICB0aGlzLl9zZW5kZXIgPSBzZW5kZXI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNlbmRlcltrV2ViU29ja2V0XSA9IHRoaXM7XG4gICAgc29ja2V0W2tXZWJTb2NrZXRdID0gdGhpcztcblxuICAgIHJlY2VpdmVyLm9uKCdjb25jbHVkZScsIHJlY2VpdmVyT25Db25jbHVkZSk7XG4gICAgcmVjZWl2ZXIub24oJ2RyYWluJywgcmVjZWl2ZXJPbkRyYWluKTtcbiAgICByZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRXJyb3IpO1xuICAgIHJlY2VpdmVyLm9uKCdtZXNzYWdlJywgcmVjZWl2ZXJPbk1lc3NhZ2UpO1xuICAgIHJlY2VpdmVyLm9uKCdwaW5nJywgcmVjZWl2ZXJPblBpbmcpO1xuICAgIHJlY2VpdmVyLm9uKCdwb25nJywgcmVjZWl2ZXJPblBvbmcpO1xuXG4gICAgc2VuZGVyLm9uZXJyb3IgPSBzZW5kZXJPbkVycm9yO1xuXG4gICAgLy9cbiAgICAvLyBUaGVzZSBtZXRob2RzIG1heSBub3QgYmUgYXZhaWxhYmxlIGlmIGBzb2NrZXRgIGlzIGp1c3QgYSBgRHVwbGV4YC5cbiAgICAvL1xuICAgIGlmIChzb2NrZXQuc2V0VGltZW91dCkgc29ja2V0LnNldFRpbWVvdXQoMCk7XG4gICAgaWYgKHNvY2tldC5zZXROb0RlbGF5KSBzb2NrZXQuc2V0Tm9EZWxheSgpO1xuXG4gICAgaWYgKGhlYWQubGVuZ3RoID4gMCkgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG5cbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gICAgc29ja2V0Lm9uKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgICBzb2NrZXQub24oJ2VuZCcsIHNvY2tldE9uRW5kKTtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0Lk9QRU47XG4gICAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCB0aGUgYCdjbG9zZSdgIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW1pdENsb3NlKCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBjbG9zaW5nIGhhbmRzaGFrZS5cbiAgICpcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tK1xuICAgKiAgICAgLSAtIC18d3MuY2xvc2UoKXwtLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC1cbiAgICogICAgfCAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tKyAgICAgfFxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgICAgICAgfFxuICAgKiBDTE9TSU5HICB8d3MuY2xvc2UoKXw8LS18Y2xvc2UgZnJhbWV8PC0tKy0tLS0tKyAgICAgICBDTE9TSU5HXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICB8XG4gICAqICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLSsgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLT58ZmlufCAtIC0gLSAtXG4gICAqICAgIHwgICAgICAgICArLS0tKyAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLStcbiAgICogICAgIC0gLSAtIC0gLXxmaW58PC0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogICAgICAgICAgICAgICstLS0rXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gU3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSByZWFzb24gd2h5IHRoZSBjb25uZWN0aW9uIGlzXG4gICAqICAgICBjbG9zaW5nXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0lORykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCAmJlxuICAgICAgICAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8IHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZClcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgaGFuZGxlZCBieSB0aGUgYCdlcnJvcidgIGxpc3RlbmVyIG9uIHRoZSBzb2NrZXQuIFdlIG9ubHlcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxuICAgICAgLy9cbiAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fFxuICAgICAgICB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzZXRDbG9zZVRpbWVyKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBhdXNlKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fc29ja2V0LnBhdXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSB0aGlzLl9zb2NrZXQucmVzdW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvclxuICAgKiAgICAgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj10cnVlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2tdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gZGF0YSBpcyB3cml0dGVuIG91dFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGJpbmFyeTogdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnLFxuICAgICAgbWFzazogIXRoaXMuX2lzU2VydmVyLFxuICAgICAgY29tcHJlc3M6IHRydWUsXG4gICAgICBmaW46IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbmRlci5zZW5kKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBvcHRzLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2libHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuW1xuICAnYmluYXJ5VHlwZScsXG4gICdidWZmZXJlZEFtb3VudCcsXG4gICdleHRlbnNpb25zJyxcbiAgJ2lzUGF1c2VkJyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3JlYWR5U3RhdGUnLFxuICAndXJsJ1xuXS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn0pO1xuXG4vL1xuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2Vcbi8vXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHJldHVybiBsaXN0ZW5lcltrTGlzdGVuZXJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGhhbmRsZXIsIHtcbiAgICAgICAgW2tGb3JPbkV2ZW50QXR0cmlidXRlXTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuV2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgY2xpZW50IHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgYW55XG4gKiAgICAgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBtdWx0aXBsZVxuICogICAgIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b1Bvbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmZpbmlzaFJlcXVlc3RdIEEgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG9cbiAqICAgICBjdXN0b21pemUgdGhlIGhlYWRlcnMgb2YgZWFjaCBodHRwIHJlcXVlc3QgYmVmb3JlIGl0IGlzIHNlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9sbG93UmVkaXJlY3RzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBmb2xsb3dcbiAqICAgICByZWRpcmVjdHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gKiAgICAgbWFza2luZyBrZXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oYW5kc2hha2VUaW1lb3V0XSBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlXG4gKiAgICAgaGFuZHNoYWtlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gKiAgICAgc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFJlZGlyZWN0cz0xMF0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlZGlyZWN0c1xuICogICAgIGFsbG93ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5vcmlnaW5dIFZhbHVlIG9mIHRoZSBgT3JpZ2luYCBvclxuICogICAgIGBTZWMtV2ViU29ja2V0LU9yaWdpbmAgaGVhZGVyXG4gKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPXRydWVdIEVuYWJsZS9kaXNhYmxlXG4gKiAgICAgcGVybWVzc2FnZS1kZWZsYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJvdG9jb2xWZXJzaW9uPTEzXSBWYWx1ZSBvZiB0aGVcbiAqICAgICBgU2VjLVdlYlNvY2tldC1WZXJzaW9uYCBoZWFkZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0cnVlLFxuICAgIGF1dG9Qb25nOiB0cnVlLFxuICAgIHByb3RvY29sVmVyc2lvbjogcHJvdG9jb2xWZXJzaW9uc1sxXSxcbiAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgIGZvbGxvd1JlZGlyZWN0czogZmFsc2UsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICAuLi5vcHRpb25zLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgaG9zdDogdW5kZWZpbmVkLFxuICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICBwb3J0OiB1bmRlZmluZWRcbiAgfTtcblxuICB3ZWJzb2NrZXQuX2F1dG9Qb25nID0gb3B0cy5hdXRvUG9uZztcblxuICBpZiAoIXByb3RvY29sVmVyc2lvbnMuaW5jbHVkZXMob3B0cy5wcm90b2NvbFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHtvcHRzLnByb3RvY29sVmVyc2lvbn0gYCArXG4gICAgICAgIGAoc3VwcG9ydGVkIHZlcnNpb25zOiAke3Byb3RvY29sVmVyc2lvbnMuam9pbignLCAnKX0pYFxuICAgICk7XG4gIH1cblxuICBsZXQgcGFyc2VkVXJsO1xuXG4gIGlmIChhZGRyZXNzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcGFyc2VkVXJsID0gYWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9ICd3czonO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3NzOic7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3VybCA9IHBhcnNlZFVybC5ocmVmO1xuXG4gIGNvbnN0IGlzU2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOic7XG4gIGNvbnN0IGlzSXBjVXJsID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xuICBsZXQgaW52YWxpZFVybE1lc3NhZ2U7XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgIWlzU2VjdXJlICYmICFpc0lwY1VybCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID1cbiAgICAgICdUaGUgVVJMXFwncyBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBcIndzOlwiLCBcIndzczpcIiwgJyArXG4gICAgICAnXCJodHRwOlwiLCBcImh0dHBzXCIsIG9yIFwid3MrdW5peDpcIic7XG4gIH0gZWxzZSBpZiAoaXNJcGNVcmwgJiYgIXBhcnNlZFVybC5wYXRobmFtZSkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID0gXCJUaGUgVVJMJ3MgcGF0aG5hbWUgaXMgZW1wdHlcIjtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID0gJ1RoZSBVUkwgY29udGFpbnMgYSBmcmFnbWVudCBpZGVudGlmaWVyJztcbiAgfVxuXG4gIGlmIChpbnZhbGlkVXJsTWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihpbnZhbGlkVXJsTWVzc2FnZSk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRQb3J0ID0gaXNTZWN1cmUgPyA0NDMgOiA4MDtcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3QgcmVxdWVzdCA9IGlzU2VjdXJlID8gaHR0cHMucmVxdWVzdCA6IGh0dHAucmVxdWVzdDtcbiAgY29uc3QgcHJvdG9jb2xTZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBwZXJNZXNzYWdlRGVmbGF0ZTtcblxuICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gPVxuICAgIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiB8fCAoaXNTZWN1cmUgPyB0bHNDb25uZWN0IDogbmV0Q29ubmVjdCk7XG4gIG9wdHMuZGVmYXVsdFBvcnQgPSBvcHRzLmRlZmF1bHRQb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLnBvcnQgPSBwYXJzZWRVcmwucG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxuICAgID8gcGFyc2VkVXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgIDogcGFyc2VkVXJsLmhvc3RuYW1lO1xuICBvcHRzLmhlYWRlcnMgPSB7XG4gICAgLi4ub3B0cy5oZWFkZXJzLFxuICAgICdTZWMtV2ViU29ja2V0LVZlcnNpb24nOiBvcHRzLnByb3RvY29sVmVyc2lvbixcbiAgICAnU2VjLVdlYlNvY2tldC1LZXknOiBrZXksXG4gICAgQ29ubmVjdGlvbjogJ1VwZ3JhZGUnLFxuICAgIFVwZ3JhZGU6ICd3ZWJzb2NrZXQnXG4gIH07XG4gIG9wdHMucGF0aCA9IHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2g7XG4gIG9wdHMudGltZW91dCA9IG9wdHMuaGFuZHNoYWtlVGltZW91dDtcblxuICBpZiAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSAhPT0gdHJ1ZSA/IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgOiB7fSxcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0cy5tYXhQYXlsb2FkXG4gICAgKTtcbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyddID0gZm9ybWF0KHtcbiAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogcGVyTWVzc2FnZURlZmxhdGUub2ZmZXIoKVxuICAgIH0pO1xuICB9XG4gIGlmIChwcm90b2NvbHMubGVuZ3RoKSB7XG4gICAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHByb3RvY29sICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhc3VicHJvdG9jb2xSZWdleC50ZXN0KHByb3RvY29sKSB8fFxuICAgICAgICBwcm90b2NvbFNldC5oYXMocHJvdG9jb2wpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgICdBbiBpbnZhbGlkIG9yIGR1cGxpY2F0ZWQgc3VicHJvdG9jb2wgd2FzIHNwZWNpZmllZCdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcHJvdG9jb2xTZXQuYWRkKHByb3RvY29sKTtcbiAgICB9XG5cbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IHByb3RvY29scy5qb2luKCcsJyk7XG4gIH1cbiAgaWYgKG9wdHMub3JpZ2luKSB7XG4gICAgaWYgKG9wdHMucHJvdG9jb2xWZXJzaW9uIDwgMTMpIHtcbiAgICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IG9wdHMub3JpZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLmhlYWRlcnMuT3JpZ2luID0gb3B0cy5vcmlnaW47XG4gICAgfVxuICB9XG4gIGlmIChwYXJzZWRVcmwudXNlcm5hbWUgfHwgcGFyc2VkVXJsLnBhc3N3b3JkKSB7XG4gICAgb3B0cy5hdXRoID0gYCR7cGFyc2VkVXJsLnVzZXJuYW1lfToke3BhcnNlZFVybC5wYXNzd29yZH1gO1xuICB9XG5cbiAgaWYgKGlzSXBjVXJsKSB7XG4gICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoJzonKTtcblxuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xuICAgIG9wdHMucGF0aCA9IHBhcnRzWzFdO1xuICB9XG5cbiAgbGV0IHJlcTtcblxuICBpZiAob3B0cy5mb2xsb3dSZWRpcmVjdHMpIHtcbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxJcGMgPSBpc0lwY1VybDtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgPSBpc1NlY3VyZTtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoID0gaXNJcGNVcmxcbiAgICAgICAgPyBvcHRzLnNvY2tldFBhdGhcbiAgICAgICAgOiBwYXJzZWRVcmwuaG9zdDtcblxuICAgICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5oZWFkZXJzO1xuXG4gICAgICAvL1xuICAgICAgLy8gU2hhbGxvdyBjb3B5IHRoZSB1c2VyIHByb3ZpZGVkIG9wdGlvbnMgc28gdGhhdCBoZWFkZXJzIGNhbiBiZSBjaGFuZ2VkXG4gICAgICAvLyB3aXRob3V0IG11dGF0aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAvL1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgaGVhZGVyczoge30gfTtcblxuICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgICBvcHRpb25zLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHdlYnNvY2tldC5saXN0ZW5lckNvdW50KCdyZWRpcmVjdCcpID09PSAwKSB7XG4gICAgICBjb25zdCBpc1NhbWVIb3N0ID0gaXNJcGNVcmxcbiAgICAgICAgPyB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjXG4gICAgICAgICAgPyBvcHRzLnNvY2tldFBhdGggPT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoXG4gICAgICAgICAgOiBmYWxzZVxuICAgICAgICA6IHdlYnNvY2tldC5fb3JpZ2luYWxJcGNcbiAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgOiBwYXJzZWRVcmwuaG9zdCA9PT0gd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGg7XG5cbiAgICAgIGlmICghaXNTYW1lSG9zdCB8fCAod2Vic29ja2V0Ll9vcmlnaW5hbFNlY3VyZSAmJiAhaXNTZWN1cmUpKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBkcm9wIHRoZSBmb2xsb3dpbmcgaGVhZGVycy4gVGhlc2VcbiAgICAgICAgLy8gaGVhZGVycyBhcmUgYWxzbyBkcm9wcGVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBzdWJkb21haW4uXG4gICAgICAgIC8vXG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5jb29raWU7XG5cbiAgICAgICAgaWYgKCFpc1NhbWVIb3N0KSBkZWxldGUgb3B0cy5oZWFkZXJzLmhvc3Q7XG5cbiAgICAgICAgb3B0cy5hdXRoID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIG1ha2UgdGhlIGZpcnN0IGBBdXRob3JpemF0aW9uYCBoZWFkZXIgd2luLlxuICAgIC8vIElmIHRoZSBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIGlzIHNldCwgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvIGFzIGl0XG4gICAgLy8gd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gICAgLy9cbiAgICBpZiAob3B0cy5hdXRoICYmICFvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbikge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPVxuICAgICAgICAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcblxuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cykge1xuICAgICAgLy9cbiAgICAgIC8vIFVubGlrZSB3aGF0IGlzIGRvbmUgZm9yIHRoZSBgJ3VwZ3JhZGUnYCBldmVudCwgbm8gZWFybHkgZXhpdCBpc1xuICAgICAgLy8gdHJpZ2dlcmVkIGhlcmUgaWYgdGhlIHVzZXIgY2FsbHMgYHdlYnNvY2tldC5jbG9zZSgpYCBvclxuICAgICAgLy8gYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgJ3JlZGlyZWN0J2AgZXZlbnQuIFRoaXNcbiAgICAgIC8vIGlzIGJlY2F1c2UgdGhlIHVzZXIgY2FuIGFsc28gY2FsbCBgcmVxdWVzdC5kZXN0cm95KClgIHdpdGggYW4gZXJyb3JcbiAgICAgIC8vIGJlZm9yZSBjYWxsaW5nIGB3ZWJzb2NrZXQuY2xvc2UoKWAgb3IgYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgYW5kIHRoaXNcbiAgICAgIC8vIHdvdWxkIHJlc3VsdCBpbiBhbiBlcnJvciBiZWluZyBlbWl0dGVkIG9uIHRoZSBgcmVxdWVzdGAgb2JqZWN0IHdpdGggbm9cbiAgICAgIC8vIGAnZXJyb3InYCBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQuXG4gICAgICAvL1xuICAgICAgd2Vic29ja2V0LmVtaXQoJ3JlZGlyZWN0Jywgd2Vic29ja2V0LnVybCwgcmVxKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSByZXF1ZXN0KG9wdHMpO1xuICB9XG5cbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dCcpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBpZiAocmVxID09PSBudWxsIHx8IHJlcVtrQWJvcnRlZF0pIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcbiAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICBpZiAoXG4gICAgICBsb2NhdGlvbiAmJlxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXG4gICAgKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQuX3JlZGlyZWN0cyA+IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgbGV0IGFkZHI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFkZHIgPSBuZXcgVVJMKGxvY2F0aW9uLCBhZGRyZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHtsb2NhdGlvbn1gKTtcbiAgICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICghd2Vic29ja2V0LmVtaXQoJ3VuZXhwZWN0ZWQtcmVzcG9uc2UnLCByZXEsIHJlcykpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKFxuICAgICAgICB3ZWJzb2NrZXQsXG4gICAgICAgIHJlcSxcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXEub24oJ3VwZ3JhZGUnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICB3ZWJzb2NrZXQuZW1pdCgndXBncmFkZScsIHJlcyk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlXG4gICAgLy8gYCd1cGdyYWRlJ2AgZXZlbnQuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG5cbiAgICBjb25zdCB1cGdyYWRlID0gcmVzLmhlYWRlcnMudXBncmFkZTtcblxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyUHJvdCA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgbGV0IHByb3RFcnJvcjtcblxuICAgIGlmIChzZXJ2ZXJQcm90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghcHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkJztcbiAgICAgIH0gZWxzZSBpZiAoIXByb3RvY29sU2V0LmhhcyhzZXJ2ZXJQcm90KSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbFNldC5zaXplKSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wnO1xuICAgIH1cblxuICAgIGlmIChwcm90RXJyb3IpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBwcm90RXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJQcm90KSB3ZWJzb2NrZXQuX3Byb3RvY29sID0gc2VydmVyUHJvdDtcblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdTZXJ2ZXIgc2VudCBhIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXIgYnV0IG5vIGV4dGVuc2lvbiAnICtcbiAgICAgICAgICAnd2FzIHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZXh0ZW5zaW9ucztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWVzID0gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgZXh0ZW5zaW9uTmFtZXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgIGV4dGVuc2lvbk5hbWVzWzBdICE9PSBQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdTZXJ2ZXIgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiB0aGF0IHdhcyBub3QgcmVxdWVzdGVkJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3ZWJzb2NrZXQuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPVxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogb3B0cy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzLFxuICAgICAgZ2VuZXJhdGVNYXNrOiBvcHRzLmdlbmVyYXRlTWFzayxcbiAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0cy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKG9wdHMuZmluaXNoUmVxdWVzdCkge1xuICAgIG9wdHMuZmluaXNoUmVxdWVzdChyZXEsIHdlYnNvY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgcmVxLmVuZCgpO1xuICB9XG59XG5cbi8qKlxuICogRW1pdCB0aGUgYCdlcnJvcidgIGFuZCBgJ2Nsb3NlJ2AgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yIHRvIGVtaXRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGFzc2lnbm1lbnQgaXMgcHJhY3RpY2FsbHkgdXNlbGVzcyBhbmQgaXMgZG9uZSBvbmx5IGZvclxuICAvLyBjb25zaXN0ZW5jeS5cbiAgLy9cbiAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYG5ldC5Tb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtuZXQuU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSAnJykge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG5ldC5pc0lQKG9wdGlvbnMuaG9zdCkgPyAnJyA6IG9wdGlvbnMuaG9zdDtcbiAgfVxuXG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0b1xuICogICAgIGFib3J0IG9yIHRoZSBzb2NrZXQgdG8gZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc3RyZWFtLCBtZXNzYWdlKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XG5cbiAgaWYgKHN0cmVhbS5zZXRIZWFkZXIpIHtcbiAgICBzdHJlYW1ba0Fib3J0ZWRdID0gdHJ1ZTtcbiAgICBzdHJlYW0uYWJvcnQoKTtcblxuICAgIGlmIChzdHJlYW0uc29ja2V0ICYmICFzdHJlYW0uc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgLy9cbiAgICAgIC8vIE9uIE5vZGUuanMgPj0gMTQuMy4wIGByZXF1ZXN0LmFib3J0KClgIGRvZXMgbm90IGRlc3Ryb3kgdGhlIHNvY2tldCBpZlxuICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSByZXF1ZXN0IGNvbXBsZXRlZC4gU2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTg2OS5cbiAgICAgIC8vXG4gICAgICBzdHJlYW0uc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlLCB3ZWJzb2NrZXQsIGVycik7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKTtcbiAgICBzdHJlYW0ub25jZSgnZXJyb3InLCB3ZWJzb2NrZXQuZW1pdC5iaW5kKHdlYnNvY2tldCwgJ2Vycm9yJykpO1xuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgYHBpbmcoKWAsIGBwb25nKClgLCBvciBgc2VuZCgpYCBtZXRob2RzIGFyZSBjYWxsZWRcbiAqIHdoZW4gdGhlIGByZWFkeVN0YXRlYCBhdHRyaWJ1dGUgaXMgYENMT1NJTkdgIG9yIGBDTE9TRURgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZEFmdGVyQ2xvc2Uod2Vic29ja2V0LCBkYXRhLCBjYikge1xuICBpZiAoZGF0YSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGlzQmxvYihkYXRhKSA/IGRhdGEuc2l6ZSA6IHRvQnVmZmVyKGRhdGEpLmxlbmd0aDtcblxuICAgIC8vXG4gICAgLy8gVGhlIGBfYnVmZmVyZWRBbW91bnRgIHByb3BlcnR5IGlzIHVzZWQgb25seSB3aGVuIHRoZSBwZWVyIGlzIGEgY2xpZW50IGFuZFxuICAgIC8vIHRoZSBvcGVuaW5nIGhhbmRzaGFrZSBmYWlscy4gVW5kZXIgdGhlc2UgY2lyY3Vtc3RhbmNlcywgaW4gZmFjdCwgdGhlXG4gICAgLy8gYHNldFNvY2tldCgpYCBtZXRob2QgaXMgbm90IGNhbGxlZCwgc28gdGhlIGBfc29ja2V0YCBhbmQgYF9zZW5kZXJgXG4gICAgLy8gcHJvcGVydGllcyBhcmUgc2V0IHRvIGBudWxsYC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQuX3NvY2tldCkgd2Vic29ja2V0Ll9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXMgKz0gbGVuZ3RoO1xuICAgIGVsc2Ugd2Vic29ja2V0Ll9idWZmZXJlZEFtb3VudCArPSBsZW5ndGg7XG4gIH1cblxuICBpZiAoY2IpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7d2Vic29ja2V0LnJlYWR5U3RhdGV9IGAgK1xuICAgICAgICBgKCR7cmVhZHlTdGF0ZXNbd2Vic29ja2V0LnJlYWR5U3RhdGVdfSlgXG4gICAgKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnY29uY2x1ZGUnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7QnVmZmVyfSByZWFzb24gVGhlIHJlYXNvbiBmb3IgY2xvc2luZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkNvbmNsdWRlKGNvZGUsIHJlYXNvbikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0Ll9jbG9zZU1lc3NhZ2UgPSByZWFzb247XG4gIHdlYnNvY2tldC5fY2xvc2VDb2RlID0gY29kZTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcblxuICBpZiAoY29kZSA9PT0gMTAwNSkgd2Vic29ja2V0LmNsb3NlKCk7XG4gIGVsc2Ugd2Vic29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZHJhaW4nYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKCF3ZWJzb2NrZXQuaXNQYXVzZWQpIHdlYnNvY2tldC5fc29ja2V0LnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoUmFuZ2VFcnJvcnxFcnJvcil9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuXG4gICAgLy9cbiAgICAvLyBPbiBOb2RlLmpzIDwgMTQuMC4wIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBzeW5jaHJvbm91c2x5LiBTZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTk0MC5cbiAgICAvL1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgICB3ZWJzb2NrZXQuY2xvc2UoZXJyW2tTdGF0dXNDb2RlXSk7XG4gIH1cblxuICBpZiAoIXdlYnNvY2tldC5fZXJyb3JFbWl0dGVkKSB7XG4gICAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdmaW5pc2gnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRmluaXNoKCkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ21lc3NhZ2UnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheUJ1ZmZlcnxCdWZmZXJbXSl9IGRhdGEgVGhlIG1lc3NhZ2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5hcnkgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgYmluYXJ5IG9yIG5vdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdtZXNzYWdlJywgZGF0YSwgaXNCaW5hcnkpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BpbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcGluZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBpbmcoZGF0YSkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX2F1dG9Qb25nKSB3ZWJzb2NrZXQucG9uZyhkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIE5PT1ApO1xuICB3ZWJzb2NrZXQuZW1pdCgncGluZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BvbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcG9uZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBvbmcoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBSZXN1bWUgYSByZWFkYWJsZSBzdHJlYW1cbiAqXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gVGhlIHJlYWRhYmxlIHN0cmVhbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSkge1xuICBzdHJlYW0ucmVzdW1lKCk7XG59XG5cbi8qKlxuICogVGhlIGBTZW5kZXJgIGVycm9yIGV2ZW50IGhhbmRsZXIuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZW5kZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgc2V0Q2xvc2VUaW1lcih3ZWJzb2NrZXQpO1xuICB9XG5cbiAgLy9cbiAgLy8gYHNvY2tldC5lbmQoKWAgaXMgdXNlZCBpbnN0ZWFkIG9mIGBzb2NrZXQuZGVzdHJveSgpYCB0byBhbGxvdyB0aGUgb3RoZXJcbiAgLy8gcGVlciB0byBmaW5pc2ggc2VuZGluZyBxdWV1ZWQgZGF0YS4gVGhlcmUgaXMgbm8gbmVlZCB0byBzZXQgYSB0aW1lciBoZXJlXG4gIC8vIGJlY2F1c2UgYENMT1NJTkdgIG1lYW5zIHRoYXQgaXQgaXMgYWxyZWFkeSBzZXQgb3Igbm90IG5lZWRlZC5cbiAgLy9cbiAgdGhpcy5fc29ja2V0LmVuZCgpO1xuXG4gIGlmICghd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQpIHtcbiAgICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIHRpbWVyIHRvIGRlc3Ryb3kgdGhlIHVuZGVybHlpbmcgcmF3IHNvY2tldCBvZiBhIFdlYlNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldENsb3NlVGltZXIod2Vic29ja2V0KSB7XG4gIHdlYnNvY2tldC5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgd2Vic29ja2V0Ll9zb2NrZXQuZGVzdHJveS5iaW5kKHdlYnNvY2tldC5fc29ja2V0KSxcbiAgICBjbG9zZVRpbWVvdXRcbiAgKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Nsb3NlJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25DbG9zZSgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgc29ja2V0T25FbmQpO1xuXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGxldCBjaHVuaztcblxuICAvL1xuICAvLyBUaGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGhhdmUgYmVlbiByZWNlaXZlZCBvciB0aGUgYCdlbmQnYCBldmVudCBlbWl0dGVkLFxuICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHNvY2tldCB3YXMgZGVzdHJveWVkIGR1ZSB0byBhbiBlcnJvci4gRW5zdXJlIHRoYXQgdGhlXG4gIC8vIGByZWNlaXZlcmAgc3RyZWFtIGlzIGNsb3NlZCBhZnRlciB3cml0aW5nIGFueSByZW1haW5pbmcgYnVmZmVyZWQgZGF0YSB0b1xuICAvLyBpdC4gSWYgdGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHNvY2tldCBpcyBpbiBmbG93aW5nIG1vZGUgdGhlbiB0aGVyZSBpcyBub1xuICAvLyBidWZmZXJlZCBkYXRhIGFzIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gYWxyZWFkeSB3cml0dGVuIGFuZCBgcmVhZGFibGUucmVhZCgpYFxuICAvLyB3aWxsIHJldHVybiBgbnVsbGAuIElmIGluc3RlYWQsIHRoZSBzb2NrZXQgaXMgcGF1c2VkLCBhbnkgcG9zc2libGUgYnVmZmVyZWRcbiAgLy8gZGF0YSB3aWxsIGJlIHJlYWQgYXMgYSBzaW5nbGUgY2h1bmsuXG4gIC8vXG4gIGlmIChcbiAgICAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkICYmXG4gICAgIXdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmXG4gICAgIXdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkICYmXG4gICAgKGNodW5rID0gd2Vic29ja2V0Ll9zb2NrZXQucmVhZCgpKSAhPT0gbnVsbFxuICApIHtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLndyaXRlKGNodW5rKTtcbiAgfVxuXG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG5cbiAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICBjbGVhclRpbWVvdXQod2Vic29ja2V0Ll9jbG9zZVRpbWVyKTtcblxuICBpZiAoXG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCB8fFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXG4gICkge1xuICAgIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25GaW5pc2gpO1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2ZpbmlzaCcsIHJlY2VpdmVyT25GaW5pc2gpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25EYXRhKGNodW5rKSB7XG4gIGlmICghdGhpc1trV2ViU29ja2V0XS5fcmVjZWl2ZXIud3JpdGUoY2h1bmspKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVuZCgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcbiAgdGhpcy5lbmQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICB0aGlzLm9uKCdlcnJvcicsIE5PT1ApO1xuXG4gIGlmICh3ZWJzb2NrZXQpIHtcbiAgICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsInJlcXVpcmUiLCJodHRwcyIsImh0dHAiLCJuZXQiLCJ0bHMiLCJyYW5kb21CeXRlcyIsImNyZWF0ZUhhc2giLCJEdXBsZXgiLCJSZWFkYWJsZSIsIlVSTCIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiUmVjZWl2ZXIiLCJTZW5kZXIiLCJpc0Jsb2IiLCJCSU5BUllfVFlQRVMiLCJFTVBUWV9CVUZGRVIiLCJHVUlEIiwia0Zvck9uRXZlbnRBdHRyaWJ1dGUiLCJrTGlzdGVuZXIiLCJrU3RhdHVzQ29kZSIsImtXZWJTb2NrZXQiLCJOT09QIiwiRXZlbnRUYXJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImZvcm1hdCIsInBhcnNlIiwidG9CdWZmZXIiLCJjbG9zZVRpbWVvdXQiLCJrQWJvcnRlZCIsIlN5bWJvbCIsInByb3RvY29sVmVyc2lvbnMiLCJyZWFkeVN0YXRlcyIsInN1YnByb3RvY29sUmVnZXgiLCJXZWJTb2NrZXQiLCJjb25zdHJ1Y3RvciIsImFkZHJlc3MiLCJwcm90b2NvbHMiLCJvcHRpb25zIiwiX2JpbmFyeVR5cGUiLCJfY2xvc2VDb2RlIiwiX2Nsb3NlRnJhbWVSZWNlaXZlZCIsIl9jbG9zZUZyYW1lU2VudCIsIl9jbG9zZU1lc3NhZ2UiLCJfY2xvc2VUaW1lciIsIl9lcnJvckVtaXR0ZWQiLCJfZXh0ZW5zaW9ucyIsIl9wYXVzZWQiLCJfcHJvdG9jb2wiLCJfcmVhZHlTdGF0ZSIsIkNPTk5FQ1RJTkciLCJfcmVjZWl2ZXIiLCJfc2VuZGVyIiwiX3NvY2tldCIsIl9idWZmZXJlZEFtb3VudCIsIl9pc1NlcnZlciIsIl9yZWRpcmVjdHMiLCJ1bmRlZmluZWQiLCJBcnJheSIsImlzQXJyYXkiLCJpbml0QXNDbGllbnQiLCJfYXV0b1BvbmciLCJhdXRvUG9uZyIsImJpbmFyeVR5cGUiLCJ0eXBlIiwiaW5jbHVkZXMiLCJidWZmZXJlZEFtb3VudCIsIl93cml0YWJsZVN0YXRlIiwibGVuZ3RoIiwiX2J1ZmZlcmVkQnl0ZXMiLCJleHRlbnNpb25zIiwiT2JqZWN0Iiwia2V5cyIsImpvaW4iLCJpc1BhdXNlZCIsIm9uY2xvc2UiLCJvbmVycm9yIiwib25vcGVuIiwib25tZXNzYWdlIiwicHJvdG9jb2wiLCJyZWFkeVN0YXRlIiwidXJsIiwiX3VybCIsInNldFNvY2tldCIsInNvY2tldCIsImhlYWQiLCJyZWNlaXZlciIsImFsbG93U3luY2hyb25vdXNFdmVudHMiLCJpc1NlcnZlciIsIm1heFBheWxvYWQiLCJza2lwVVRGOFZhbGlkYXRpb24iLCJzZW5kZXIiLCJnZW5lcmF0ZU1hc2siLCJvbiIsInJlY2VpdmVyT25Db25jbHVkZSIsInJlY2VpdmVyT25EcmFpbiIsInJlY2VpdmVyT25FcnJvciIsInJlY2VpdmVyT25NZXNzYWdlIiwicmVjZWl2ZXJPblBpbmciLCJyZWNlaXZlck9uUG9uZyIsInNlbmRlck9uRXJyb3IiLCJzZXRUaW1lb3V0Iiwic2V0Tm9EZWxheSIsInVuc2hpZnQiLCJzb2NrZXRPbkNsb3NlIiwic29ja2V0T25EYXRhIiwic29ja2V0T25FbmQiLCJzb2NrZXRPbkVycm9yIiwiT1BFTiIsImVtaXQiLCJlbWl0Q2xvc2UiLCJDTE9TRUQiLCJleHRlbnNpb25OYW1lIiwiY2xlYW51cCIsInJlbW92ZUFsbExpc3RlbmVycyIsImNsb3NlIiwiY29kZSIsImRhdGEiLCJtc2ciLCJhYm9ydEhhbmRzaGFrZSIsIl9yZXEiLCJDTE9TSU5HIiwiZXJyb3JFbWl0dGVkIiwiZW5kIiwiZXJyIiwic2V0Q2xvc2VUaW1lciIsInBhdXNlIiwicGluZyIsIm1hc2siLCJjYiIsIkVycm9yIiwidG9TdHJpbmciLCJzZW5kQWZ0ZXJDbG9zZSIsInBvbmciLCJyZXN1bWUiLCJuZWVkRHJhaW4iLCJzZW5kIiwib3B0cyIsImJpbmFyeSIsImNvbXByZXNzIiwiZmluIiwidGVybWluYXRlIiwiZGVzdHJveSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsInZhbHVlIiwiaW5kZXhPZiIsInByb3RvdHlwZSIsImZvckVhY2giLCJwcm9wZXJ0eSIsIm1ldGhvZCIsImdldCIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwic2V0IiwiaGFuZGxlciIsInJlbW92ZUxpc3RlbmVyIiwibW9kdWxlIiwiZXhwb3J0cyIsIndlYnNvY2tldCIsInByb3RvY29sVmVyc2lvbiIsInBlck1lc3NhZ2VEZWZsYXRlIiwiZm9sbG93UmVkaXJlY3RzIiwibWF4UmVkaXJlY3RzIiwic29ja2V0UGF0aCIsImhvc3RuYW1lIiwidGltZW91dCIsImhvc3QiLCJwYXRoIiwicG9ydCIsIlJhbmdlRXJyb3IiLCJwYXJzZWRVcmwiLCJlIiwiU3ludGF4RXJyb3IiLCJocmVmIiwiaXNTZWN1cmUiLCJpc0lwY1VybCIsImludmFsaWRVcmxNZXNzYWdlIiwicGF0aG5hbWUiLCJoYXNoIiwiZW1pdEVycm9yQW5kQ2xvc2UiLCJkZWZhdWx0UG9ydCIsImtleSIsInJlcXVlc3QiLCJwcm90b2NvbFNldCIsIlNldCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJ0bHNDb25uZWN0IiwibmV0Q29ubmVjdCIsInN0YXJ0c1dpdGgiLCJzbGljZSIsImhlYWRlcnMiLCJDb25uZWN0aW9uIiwiVXBncmFkZSIsInNlYXJjaCIsImhhbmRzaGFrZVRpbWVvdXQiLCJvZmZlciIsInRlc3QiLCJoYXMiLCJhZGQiLCJvcmlnaW4iLCJPcmlnaW4iLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiYXV0aCIsInBhcnRzIiwic3BsaXQiLCJyZXEiLCJfb3JpZ2luYWxJcGMiLCJfb3JpZ2luYWxTZWN1cmUiLCJfb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoIiwiZW50cmllcyIsInRvTG93ZXJDYXNlIiwibGlzdGVuZXJDb3VudCIsImlzU2FtZUhvc3QiLCJhdXRob3JpemF0aW9uIiwiY29va2llIiwiQnVmZmVyIiwiZnJvbSIsInJlcyIsImxvY2F0aW9uIiwic3RhdHVzQ29kZSIsImFib3J0IiwiYWRkciIsInVwZ3JhZGUiLCJkaWdlc3QiLCJ1cGRhdGUiLCJzZXJ2ZXJQcm90IiwicHJvdEVycm9yIiwic2l6ZSIsInNlY1dlYlNvY2tldEV4dGVuc2lvbnMiLCJtZXNzYWdlIiwiZXh0ZW5zaW9uTmFtZXMiLCJhY2NlcHQiLCJmaW5pc2hSZXF1ZXN0IiwiY29ubmVjdCIsInNlcnZlcm5hbWUiLCJpc0lQIiwic3RyZWFtIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJzZXRIZWFkZXIiLCJkZXN0cm95ZWQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJvbmNlIiwiYmluZCIsInJlYXNvbiIsInJlY2VpdmVyT25GaW5pc2giLCJpc0JpbmFyeSIsImNodW5rIiwiX3JlYWRhYmxlU3RhdGUiLCJlbmRFbWl0dGVkIiwicmVhZCIsIndyaXRlIiwiY2xlYXJUaW1lb3V0IiwiZmluaXNoZWQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/websocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/wrapper.mjs":
/*!*************************************!*\
  !*** ./node_modules/ws/wrapper.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Receiver: () => (/* reexport default export from named module */ _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   Sender: () => (/* reexport default export from named module */ _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   WebSocket: () => (/* reexport default export from named module */ _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   WebSocketServer: () => (/* reexport default export from named module */ _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   createWebSocketStream: () => (/* reexport default export from named module */ _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stream.js */ \"(rsc)/./node_modules/ws/lib/stream.js\");\n/* harmony import */ var _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/receiver.js */ \"(rsc)/./node_modules/ws/lib/receiver.js\");\n/* harmony import */ var _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/sender.js */ \"(rsc)/./node_modules/ws/lib/sender.js\");\n/* harmony import */ var _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket.js */ \"(rsc)/./node_modules/ws/lib/websocket.js\");\n/* harmony import */ var _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/websocket-server.js */ \"(rsc)/./node_modules/ws/lib/websocket-server.js\");\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3Mvd3JhcHBlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBb0Q7QUFDWDtBQUNKO0FBQ007QUFDYTtBQUV1QjtBQUMvRSxpRUFBZUcsOENBQVMiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3dzL3dyYXBwZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVXZWJTb2NrZXRTdHJlYW0gZnJvbSAnLi9saWIvc3RyZWFtLmpzJztcbmltcG9ydCBSZWNlaXZlciBmcm9tICcuL2xpYi9yZWNlaXZlci5qcyc7XG5pbXBvcnQgU2VuZGVyIGZyb20gJy4vbGliL3NlbmRlci5qcyc7XG5pbXBvcnQgV2ViU29ja2V0IGZyb20gJy4vbGliL3dlYnNvY2tldC5qcyc7XG5pbXBvcnQgV2ViU29ja2V0U2VydmVyIGZyb20gJy4vbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMnO1xuXG5leHBvcnQgeyBjcmVhdGVXZWJTb2NrZXRTdHJlYW0sIFJlY2VpdmVyLCBTZW5kZXIsIFdlYlNvY2tldCwgV2ViU29ja2V0U2VydmVyIH07XG5leHBvcnQgZGVmYXVsdCBXZWJTb2NrZXQ7XG4iXSwibmFtZXMiOlsiY3JlYXRlV2ViU29ja2V0U3RyZWFtIiwiUmVjZWl2ZXIiLCJTZW5kZXIiLCJXZWJTb2NrZXQiLCJXZWJTb2NrZXRTZXJ2ZXIiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/wrapper.mjs\n");

/***/ })

};
;